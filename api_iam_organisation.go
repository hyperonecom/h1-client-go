/*
HyperOne

HyperOne API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
	"os"
)

// Linger please
var (
	_ context.Context
)

// IamOrganisationApiService IamOrganisationApi service
type IamOrganisationApiService service

type ApiIamOrganisationBillingListRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	start *time.Time
	end *time.Time
	resourceType *string
}

// start
func (r ApiIamOrganisationBillingListRequest) Start(start time.Time) ApiIamOrganisationBillingListRequest {
	r.start = &start
	return r
}
// end
func (r ApiIamOrganisationBillingListRequest) End(end time.Time) ApiIamOrganisationBillingListRequest {
	r.end = &end
	return r
}
// resource.type
func (r ApiIamOrganisationBillingListRequest) ResourceType(resourceType string) ApiIamOrganisationBillingListRequest {
	r.resourceType = &resourceType
	return r
}

func (r ApiIamOrganisationBillingListRequest) Execute() ([]Billing, *http.Response, error) {
	return r.ApiService.IamOrganisationBillingListExecute(r)
}

/*
IamOrganisationBillingList List iam/organisation.billing

List iam/organisation.billing

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @return ApiIamOrganisationBillingListRequest
*/
func (a *IamOrganisationApiService) IamOrganisationBillingList(ctx context.Context, organisationId string) ApiIamOrganisationBillingListRequest {
	return ApiIamOrganisationBillingListRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

// Execute executes the request
//  @return []Billing
func (a *IamOrganisationApiService) IamOrganisationBillingListExecute(r ApiIamOrganisationBillingListRequest) ([]Billing, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Billing
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationBillingList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/billing"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.resourceType != nil {
		localVarQueryParams.Add("resource.type", parameterToString(*r.resourceType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationCreateRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	iamOrganisationCreate *IamOrganisationCreate
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiIamOrganisationCreateRequest) IamOrganisationCreate(iamOrganisationCreate IamOrganisationCreate) ApiIamOrganisationCreateRequest {
	r.iamOrganisationCreate = &iamOrganisationCreate
	return r
}
// Idempotency key
func (r ApiIamOrganisationCreateRequest) XIdempotencyKey(xIdempotencyKey string) ApiIamOrganisationCreateRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
// Dry run
func (r ApiIamOrganisationCreateRequest) XDryRun(xDryRun string) ApiIamOrganisationCreateRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiIamOrganisationCreateRequest) Execute() (*Organisation, *http.Response, error) {
	return r.ApiService.IamOrganisationCreateExecute(r)
}

/*
IamOrganisationCreate Create iam/organisation

Create organisation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIamOrganisationCreateRequest
*/
func (a *IamOrganisationApiService) IamOrganisationCreate(ctx context.Context) ApiIamOrganisationCreateRequest {
	return ApiIamOrganisationCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Organisation
func (a *IamOrganisationApiService) IamOrganisationCreateExecute(r ApiIamOrganisationCreateRequest) (*Organisation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Organisation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iamOrganisationCreate == nil {
		return localVarReturnValue, nil, reportError("iamOrganisationCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	// body params
	localVarPostBody = r.iamOrganisationCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationDeleteRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
}


func (r ApiIamOrganisationDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.IamOrganisationDeleteExecute(r)
}

/*
IamOrganisationDelete Delete iam/organisation

Delete organisation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @return ApiIamOrganisationDeleteRequest
*/
func (a *IamOrganisationApiService) IamOrganisationDelete(ctx context.Context, organisationId string) ApiIamOrganisationDeleteRequest {
	return ApiIamOrganisationDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

// Execute executes the request
func (a *IamOrganisationApiService) IamOrganisationDeleteExecute(r ApiIamOrganisationDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIamOrganisationEventGetRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	eventId string
}


func (r ApiIamOrganisationEventGetRequest) Execute() (*Event, *http.Response, error) {
	return r.ApiService.IamOrganisationEventGetExecute(r)
}

/*
IamOrganisationEventGet Get iam/organisation.event

Get iam/organisation.event

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @param eventId eventId
 @return ApiIamOrganisationEventGetRequest
*/
func (a *IamOrganisationApiService) IamOrganisationEventGet(ctx context.Context, organisationId string, eventId string) ApiIamOrganisationEventGetRequest {
	return ApiIamOrganisationEventGetRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return Event
func (a *IamOrganisationApiService) IamOrganisationEventGetExecute(r ApiIamOrganisationEventGetRequest) (*Event, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationEventGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/event/{eventId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", url.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationEventListRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	limit *float32
	skip *float32
}

// $limit
func (r ApiIamOrganisationEventListRequest) Limit(limit float32) ApiIamOrganisationEventListRequest {
	r.limit = &limit
	return r
}
// $skip
func (r ApiIamOrganisationEventListRequest) Skip(skip float32) ApiIamOrganisationEventListRequest {
	r.skip = &skip
	return r
}

func (r ApiIamOrganisationEventListRequest) Execute() ([]Event, *http.Response, error) {
	return r.ApiService.IamOrganisationEventListExecute(r)
}

/*
IamOrganisationEventList List iam/organisation.event

List iam/organisation.event

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @return ApiIamOrganisationEventListRequest
*/
func (a *IamOrganisationApiService) IamOrganisationEventList(ctx context.Context, organisationId string) ApiIamOrganisationEventListRequest {
	return ApiIamOrganisationEventListRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

// Execute executes the request
//  @return []Event
func (a *IamOrganisationApiService) IamOrganisationEventListExecute(r ApiIamOrganisationEventListRequest) ([]Event, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationEventList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/event"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("$limit", parameterToString(*r.limit, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationGetRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
}


func (r ApiIamOrganisationGetRequest) Execute() (*Organisation, *http.Response, error) {
	return r.ApiService.IamOrganisationGetExecute(r)
}

/*
IamOrganisationGet Get iam/organisation

Returns a single organisation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @return ApiIamOrganisationGetRequest
*/
func (a *IamOrganisationApiService) IamOrganisationGet(ctx context.Context, organisationId string) ApiIamOrganisationGetRequest {
	return ApiIamOrganisationGetRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

// Execute executes the request
//  @return Organisation
func (a *IamOrganisationApiService) IamOrganisationGetExecute(r ApiIamOrganisationGetRequest) (*Organisation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Organisation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationInvitationAcceptRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	invitationId string
	iamOrganisationInvitationAccept *IamOrganisationInvitationAccept
}

func (r ApiIamOrganisationInvitationAcceptRequest) IamOrganisationInvitationAccept(iamOrganisationInvitationAccept IamOrganisationInvitationAccept) ApiIamOrganisationInvitationAcceptRequest {
	r.iamOrganisationInvitationAccept = &iamOrganisationInvitationAccept
	return r
}

func (r ApiIamOrganisationInvitationAcceptRequest) Execute() (*Invitation, *http.Response, error) {
	return r.ApiService.IamOrganisationInvitationAcceptExecute(r)
}

/*
IamOrganisationInvitationAccept Accept iam/organisation.invitation

action accept

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @param invitationId invitationId
 @return ApiIamOrganisationInvitationAcceptRequest
*/
func (a *IamOrganisationApiService) IamOrganisationInvitationAccept(ctx context.Context, organisationId string, invitationId string) ApiIamOrganisationInvitationAcceptRequest {
	return ApiIamOrganisationInvitationAcceptRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		invitationId: invitationId,
	}
}

// Execute executes the request
//  @return Invitation
func (a *IamOrganisationApiService) IamOrganisationInvitationAcceptExecute(r ApiIamOrganisationInvitationAcceptRequest) (*Invitation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Invitation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationInvitationAccept")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/invitation/{invitationId}/actions/accept"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invitationId"+"}", url.PathEscape(parameterToString(r.invitationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iamOrganisationInvitationAccept == nil {
		return localVarReturnValue, nil, reportError("iamOrganisationInvitationAccept is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iamOrganisationInvitationAccept
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationInvitationDeleteRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	invitationId string
}


func (r ApiIamOrganisationInvitationDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.IamOrganisationInvitationDeleteExecute(r)
}

/*
IamOrganisationInvitationDelete Delete iam/organisation.invitation

Delete iam/organisation.invitation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @param invitationId invitationId
 @return ApiIamOrganisationInvitationDeleteRequest
*/
func (a *IamOrganisationApiService) IamOrganisationInvitationDelete(ctx context.Context, organisationId string, invitationId string) ApiIamOrganisationInvitationDeleteRequest {
	return ApiIamOrganisationInvitationDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		invitationId: invitationId,
	}
}

// Execute executes the request
func (a *IamOrganisationApiService) IamOrganisationInvitationDeleteExecute(r ApiIamOrganisationInvitationDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationInvitationDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/invitation/{invitationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invitationId"+"}", url.PathEscape(parameterToString(r.invitationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIamOrganisationInvitationGetRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	invitationId string
}


func (r ApiIamOrganisationInvitationGetRequest) Execute() (*Invitation, *http.Response, error) {
	return r.ApiService.IamOrganisationInvitationGetExecute(r)
}

/*
IamOrganisationInvitationGet Get iam/organisation.invitation

Get iam/organisation.invitation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @param invitationId invitationId
 @return ApiIamOrganisationInvitationGetRequest
*/
func (a *IamOrganisationApiService) IamOrganisationInvitationGet(ctx context.Context, organisationId string, invitationId string) ApiIamOrganisationInvitationGetRequest {
	return ApiIamOrganisationInvitationGetRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		invitationId: invitationId,
	}
}

// Execute executes the request
//  @return Invitation
func (a *IamOrganisationApiService) IamOrganisationInvitationGetExecute(r ApiIamOrganisationInvitationGetRequest) (*Invitation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Invitation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationInvitationGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/invitation/{invitationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invitationId"+"}", url.PathEscape(parameterToString(r.invitationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationInvitationListRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	resource *string
}

// resource
func (r ApiIamOrganisationInvitationListRequest) Resource(resource string) ApiIamOrganisationInvitationListRequest {
	r.resource = &resource
	return r
}

func (r ApiIamOrganisationInvitationListRequest) Execute() ([]Invitation, *http.Response, error) {
	return r.ApiService.IamOrganisationInvitationListExecute(r)
}

/*
IamOrganisationInvitationList List iam/organisation.invitation

List iam/organisation.invitation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @return ApiIamOrganisationInvitationListRequest
*/
func (a *IamOrganisationApiService) IamOrganisationInvitationList(ctx context.Context, organisationId string) ApiIamOrganisationInvitationListRequest {
	return ApiIamOrganisationInvitationListRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

// Execute executes the request
//  @return []Invitation
func (a *IamOrganisationApiService) IamOrganisationInvitationListExecute(r ApiIamOrganisationInvitationListRequest) ([]Invitation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Invitation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationInvitationList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/invitation"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.resource != nil {
		localVarQueryParams.Add("resource", parameterToString(*r.resource, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationInvoiceDownloadRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	invoiceId string
}


func (r ApiIamOrganisationInvoiceDownloadRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.IamOrganisationInvoiceDownloadExecute(r)
}

/*
IamOrganisationInvoiceDownload Download iam/organisation.invoice

action download

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @param invoiceId invoiceId
 @return ApiIamOrganisationInvoiceDownloadRequest
*/
func (a *IamOrganisationApiService) IamOrganisationInvoiceDownload(ctx context.Context, organisationId string, invoiceId string) ApiIamOrganisationInvoiceDownloadRequest {
	return ApiIamOrganisationInvoiceDownloadRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		invoiceId: invoiceId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *IamOrganisationApiService) IamOrganisationInvoiceDownloadExecute(r ApiIamOrganisationInvoiceDownloadRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationInvoiceDownload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/invoice/{invoiceId}/actions/download"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterToString(r.invoiceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/pdf", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationInvoiceGetRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	invoiceId string
}


func (r ApiIamOrganisationInvoiceGetRequest) Execute() (*Invoice, *http.Response, error) {
	return r.ApiService.IamOrganisationInvoiceGetExecute(r)
}

/*
IamOrganisationInvoiceGet Get iam/organisation.invoice

Get iam/organisation.invoice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @param invoiceId invoiceId
 @return ApiIamOrganisationInvoiceGetRequest
*/
func (a *IamOrganisationApiService) IamOrganisationInvoiceGet(ctx context.Context, organisationId string, invoiceId string) ApiIamOrganisationInvoiceGetRequest {
	return ApiIamOrganisationInvoiceGetRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		invoiceId: invoiceId,
	}
}

// Execute executes the request
//  @return Invoice
func (a *IamOrganisationApiService) IamOrganisationInvoiceGetExecute(r ApiIamOrganisationInvoiceGetRequest) (*Invoice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Invoice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationInvoiceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/invoice/{invoiceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", url.PathEscape(parameterToString(r.invoiceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationInvoiceListRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
}


func (r ApiIamOrganisationInvoiceListRequest) Execute() ([]Invoice, *http.Response, error) {
	return r.ApiService.IamOrganisationInvoiceListExecute(r)
}

/*
IamOrganisationInvoiceList List iam/organisation.invoice

List iam/organisation.invoice

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @return ApiIamOrganisationInvoiceListRequest
*/
func (a *IamOrganisationApiService) IamOrganisationInvoiceList(ctx context.Context, organisationId string) ApiIamOrganisationInvoiceListRequest {
	return ApiIamOrganisationInvoiceListRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

// Execute executes the request
//  @return []Invoice
func (a *IamOrganisationApiService) IamOrganisationInvoiceListExecute(r ApiIamOrganisationInvoiceListRequest) ([]Invoice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Invoice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationInvoiceList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/invoice"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationListRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	name *string
	billingCompany *string
	limit *float32
	active *bool
}

// Filter by name
func (r ApiIamOrganisationListRequest) Name(name string) ApiIamOrganisationListRequest {
	r.name = &name
	return r
}
// Filter by billing.company
func (r ApiIamOrganisationListRequest) BillingCompany(billingCompany string) ApiIamOrganisationListRequest {
	r.billingCompany = &billingCompany
	return r
}
// Filter by $limit
func (r ApiIamOrganisationListRequest) Limit(limit float32) ApiIamOrganisationListRequest {
	r.limit = &limit
	return r
}
// Filter by active
func (r ApiIamOrganisationListRequest) Active(active bool) ApiIamOrganisationListRequest {
	r.active = &active
	return r
}

func (r ApiIamOrganisationListRequest) Execute() ([]Organisation, *http.Response, error) {
	return r.ApiService.IamOrganisationListExecute(r)
}

/*
IamOrganisationList List iam/organisation

List organisation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIamOrganisationListRequest
*/
func (a *IamOrganisationApiService) IamOrganisationList(ctx context.Context) ApiIamOrganisationListRequest {
	return ApiIamOrganisationListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Organisation
func (a *IamOrganisationApiService) IamOrganisationListExecute(r ApiIamOrganisationListRequest) ([]Organisation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Organisation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.billingCompany != nil {
		localVarQueryParams.Add("billing.company", parameterToString(*r.billingCompany, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("$limit", parameterToString(*r.limit, ""))
	}
	if r.active != nil {
		localVarQueryParams.Add("active", parameterToString(*r.active, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationOwnershipCreateRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	iamOrganisationOwnershipCreate *IamOrganisationOwnershipCreate
}

func (r ApiIamOrganisationOwnershipCreateRequest) IamOrganisationOwnershipCreate(iamOrganisationOwnershipCreate IamOrganisationOwnershipCreate) ApiIamOrganisationOwnershipCreateRequest {
	r.iamOrganisationOwnershipCreate = &iamOrganisationOwnershipCreate
	return r
}

func (r ApiIamOrganisationOwnershipCreateRequest) Execute() (*Organisation, *http.Response, error) {
	return r.ApiService.IamOrganisationOwnershipCreateExecute(r)
}

/*
IamOrganisationOwnershipCreate Create iam/organisation.ownership

Create iam/organisation.ownership

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @return ApiIamOrganisationOwnershipCreateRequest
*/
func (a *IamOrganisationApiService) IamOrganisationOwnershipCreate(ctx context.Context, organisationId string) ApiIamOrganisationOwnershipCreateRequest {
	return ApiIamOrganisationOwnershipCreateRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

// Execute executes the request
//  @return Organisation
func (a *IamOrganisationApiService) IamOrganisationOwnershipCreateExecute(r ApiIamOrganisationOwnershipCreateRequest) (*Organisation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Organisation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationOwnershipCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/ownership"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iamOrganisationOwnershipCreate == nil {
		return localVarReturnValue, nil, reportError("iamOrganisationOwnershipCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iamOrganisationOwnershipCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationOwnershipDeleteRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	ownershipId string
}


func (r ApiIamOrganisationOwnershipDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.IamOrganisationOwnershipDeleteExecute(r)
}

/*
IamOrganisationOwnershipDelete Delete iam/organisation.ownership

Delete iam/organisation.ownership

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @param ownershipId ownershipId
 @return ApiIamOrganisationOwnershipDeleteRequest
*/
func (a *IamOrganisationApiService) IamOrganisationOwnershipDelete(ctx context.Context, organisationId string, ownershipId string) ApiIamOrganisationOwnershipDeleteRequest {
	return ApiIamOrganisationOwnershipDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		ownershipId: ownershipId,
	}
}

// Execute executes the request
func (a *IamOrganisationApiService) IamOrganisationOwnershipDeleteExecute(r ApiIamOrganisationOwnershipDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationOwnershipDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/ownership/{ownershipId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ownershipId"+"}", url.PathEscape(parameterToString(r.ownershipId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIamOrganisationOwnershipGetRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	ownershipId string
}


func (r ApiIamOrganisationOwnershipGetRequest) Execute() (*Ownership, *http.Response, error) {
	return r.ApiService.IamOrganisationOwnershipGetExecute(r)
}

/*
IamOrganisationOwnershipGet Get iam/organisation.ownership

Get iam/organisation.ownership

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @param ownershipId ownershipId
 @return ApiIamOrganisationOwnershipGetRequest
*/
func (a *IamOrganisationApiService) IamOrganisationOwnershipGet(ctx context.Context, organisationId string, ownershipId string) ApiIamOrganisationOwnershipGetRequest {
	return ApiIamOrganisationOwnershipGetRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		ownershipId: ownershipId,
	}
}

// Execute executes the request
//  @return Ownership
func (a *IamOrganisationApiService) IamOrganisationOwnershipGetExecute(r ApiIamOrganisationOwnershipGetRequest) (*Ownership, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Ownership
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationOwnershipGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/ownership/{ownershipId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ownershipId"+"}", url.PathEscape(parameterToString(r.ownershipId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationOwnershipListRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
}


func (r ApiIamOrganisationOwnershipListRequest) Execute() ([]Ownership, *http.Response, error) {
	return r.ApiService.IamOrganisationOwnershipListExecute(r)
}

/*
IamOrganisationOwnershipList List iam/organisation.ownership

List iam/organisation.ownership

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @return ApiIamOrganisationOwnershipListRequest
*/
func (a *IamOrganisationApiService) IamOrganisationOwnershipList(ctx context.Context, organisationId string) ApiIamOrganisationOwnershipListRequest {
	return ApiIamOrganisationOwnershipListRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

// Execute executes the request
//  @return []Ownership
func (a *IamOrganisationApiService) IamOrganisationOwnershipListExecute(r ApiIamOrganisationOwnershipListRequest) ([]Ownership, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Ownership
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationOwnershipList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/ownership"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationPaymentAllocateRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	paymentId string
	iamOrganisationPaymentAllocate *IamOrganisationPaymentAllocate
}

func (r ApiIamOrganisationPaymentAllocateRequest) IamOrganisationPaymentAllocate(iamOrganisationPaymentAllocate IamOrganisationPaymentAllocate) ApiIamOrganisationPaymentAllocateRequest {
	r.iamOrganisationPaymentAllocate = &iamOrganisationPaymentAllocate
	return r
}

func (r ApiIamOrganisationPaymentAllocateRequest) Execute() (*Payment, *http.Response, error) {
	return r.ApiService.IamOrganisationPaymentAllocateExecute(r)
}

/*
IamOrganisationPaymentAllocate Allocate iam/organisation.payment

action allocate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @param paymentId paymentId
 @return ApiIamOrganisationPaymentAllocateRequest
*/
func (a *IamOrganisationApiService) IamOrganisationPaymentAllocate(ctx context.Context, organisationId string, paymentId string) ApiIamOrganisationPaymentAllocateRequest {
	return ApiIamOrganisationPaymentAllocateRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		paymentId: paymentId,
	}
}

// Execute executes the request
//  @return Payment
func (a *IamOrganisationApiService) IamOrganisationPaymentAllocateExecute(r ApiIamOrganisationPaymentAllocateRequest) (*Payment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Payment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationPaymentAllocate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/payment/{paymentId}/actions/allocate"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"paymentId"+"}", url.PathEscape(parameterToString(r.paymentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iamOrganisationPaymentAllocate == nil {
		return localVarReturnValue, nil, reportError("iamOrganisationPaymentAllocate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iamOrganisationPaymentAllocate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationPaymentGetRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	paymentId string
}


func (r ApiIamOrganisationPaymentGetRequest) Execute() (*Payment, *http.Response, error) {
	return r.ApiService.IamOrganisationPaymentGetExecute(r)
}

/*
IamOrganisationPaymentGet Get iam/organisation.payment

Get iam/organisation.payment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @param paymentId paymentId
 @return ApiIamOrganisationPaymentGetRequest
*/
func (a *IamOrganisationApiService) IamOrganisationPaymentGet(ctx context.Context, organisationId string, paymentId string) ApiIamOrganisationPaymentGetRequest {
	return ApiIamOrganisationPaymentGetRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		paymentId: paymentId,
	}
}

// Execute executes the request
//  @return Payment
func (a *IamOrganisationApiService) IamOrganisationPaymentGetExecute(r ApiIamOrganisationPaymentGetRequest) (*Payment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Payment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationPaymentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/payment/{paymentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"paymentId"+"}", url.PathEscape(parameterToString(r.paymentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationPaymentListRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
}


func (r ApiIamOrganisationPaymentListRequest) Execute() ([]Payment, *http.Response, error) {
	return r.ApiService.IamOrganisationPaymentListExecute(r)
}

/*
IamOrganisationPaymentList List iam/organisation.payment

List iam/organisation.payment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @return ApiIamOrganisationPaymentListRequest
*/
func (a *IamOrganisationApiService) IamOrganisationPaymentList(ctx context.Context, organisationId string) ApiIamOrganisationPaymentListRequest {
	return ApiIamOrganisationPaymentListRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

// Execute executes the request
//  @return []Payment
func (a *IamOrganisationApiService) IamOrganisationPaymentListExecute(r ApiIamOrganisationPaymentListRequest) ([]Payment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Payment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationPaymentList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/payment"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationProformaCreateRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	iamOrganisationProformaCreate *IamOrganisationProformaCreate
}

func (r ApiIamOrganisationProformaCreateRequest) IamOrganisationProformaCreate(iamOrganisationProformaCreate IamOrganisationProformaCreate) ApiIamOrganisationProformaCreateRequest {
	r.iamOrganisationProformaCreate = &iamOrganisationProformaCreate
	return r
}

func (r ApiIamOrganisationProformaCreateRequest) Execute() (*Proforma, *http.Response, error) {
	return r.ApiService.IamOrganisationProformaCreateExecute(r)
}

/*
IamOrganisationProformaCreate Create iam/organisation.proforma

Create iam/organisation.proforma

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @return ApiIamOrganisationProformaCreateRequest
*/
func (a *IamOrganisationApiService) IamOrganisationProformaCreate(ctx context.Context, organisationId string) ApiIamOrganisationProformaCreateRequest {
	return ApiIamOrganisationProformaCreateRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

// Execute executes the request
//  @return Proforma
func (a *IamOrganisationApiService) IamOrganisationProformaCreateExecute(r ApiIamOrganisationProformaCreateRequest) (*Proforma, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Proforma
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationProformaCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/proforma"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iamOrganisationProformaCreate == nil {
		return localVarReturnValue, nil, reportError("iamOrganisationProformaCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iamOrganisationProformaCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationProformaDownloadRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	proformaId string
}


func (r ApiIamOrganisationProformaDownloadRequest) Execute() (**os.File, *http.Response, error) {
	return r.ApiService.IamOrganisationProformaDownloadExecute(r)
}

/*
IamOrganisationProformaDownload Download iam/organisation.proforma

action download

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @param proformaId proformaId
 @return ApiIamOrganisationProformaDownloadRequest
*/
func (a *IamOrganisationApiService) IamOrganisationProformaDownload(ctx context.Context, organisationId string, proformaId string) ApiIamOrganisationProformaDownloadRequest {
	return ApiIamOrganisationProformaDownloadRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		proformaId: proformaId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *IamOrganisationApiService) IamOrganisationProformaDownloadExecute(r ApiIamOrganisationProformaDownloadRequest) (**os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  **os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationProformaDownload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/proforma/{proformaId}/actions/download"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"proformaId"+"}", url.PathEscape(parameterToString(r.proformaId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/pdf", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationProformaGetRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	proformaId string
}


func (r ApiIamOrganisationProformaGetRequest) Execute() (*Proforma, *http.Response, error) {
	return r.ApiService.IamOrganisationProformaGetExecute(r)
}

/*
IamOrganisationProformaGet Get iam/organisation.proforma

Get iam/organisation.proforma

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @param proformaId proformaId
 @return ApiIamOrganisationProformaGetRequest
*/
func (a *IamOrganisationApiService) IamOrganisationProformaGet(ctx context.Context, organisationId string, proformaId string) ApiIamOrganisationProformaGetRequest {
	return ApiIamOrganisationProformaGetRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		proformaId: proformaId,
	}
}

// Execute executes the request
//  @return Proforma
func (a *IamOrganisationApiService) IamOrganisationProformaGetExecute(r ApiIamOrganisationProformaGetRequest) (*Proforma, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Proforma
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationProformaGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/proforma/{proformaId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"proformaId"+"}", url.PathEscape(parameterToString(r.proformaId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationProformaListRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
}


func (r ApiIamOrganisationProformaListRequest) Execute() ([]Proforma, *http.Response, error) {
	return r.ApiService.IamOrganisationProformaListExecute(r)
}

/*
IamOrganisationProformaList List iam/organisation.proforma

List iam/organisation.proforma

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @return ApiIamOrganisationProformaListRequest
*/
func (a *IamOrganisationApiService) IamOrganisationProformaList(ctx context.Context, organisationId string) ApiIamOrganisationProformaListRequest {
	return ApiIamOrganisationProformaListRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

// Execute executes the request
//  @return []Proforma
func (a *IamOrganisationApiService) IamOrganisationProformaListExecute(r ApiIamOrganisationProformaListRequest) ([]Proforma, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Proforma
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationProformaList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/proforma"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationServiceGetRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	serviceId string
}


func (r ApiIamOrganisationServiceGetRequest) Execute() (*ResourceService, *http.Response, error) {
	return r.ApiService.IamOrganisationServiceGetExecute(r)
}

/*
IamOrganisationServiceGet Get iam/organisation.service

Get iam/organisation.service

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @param serviceId serviceId
 @return ApiIamOrganisationServiceGetRequest
*/
func (a *IamOrganisationApiService) IamOrganisationServiceGet(ctx context.Context, organisationId string, serviceId string) ApiIamOrganisationServiceGetRequest {
	return ApiIamOrganisationServiceGetRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return ResourceService
func (a *IamOrganisationApiService) IamOrganisationServiceGetExecute(r ApiIamOrganisationServiceGetRequest) (*ResourceService, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourceService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationServiceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/service/{serviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serviceId"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationServiceListRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
}


func (r ApiIamOrganisationServiceListRequest) Execute() ([]ResourceService, *http.Response, error) {
	return r.ApiService.IamOrganisationServiceListExecute(r)
}

/*
IamOrganisationServiceList List iam/organisation.service

List iam/organisation.service

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @return ApiIamOrganisationServiceListRequest
*/
func (a *IamOrganisationApiService) IamOrganisationServiceList(ctx context.Context, organisationId string) ApiIamOrganisationServiceListRequest {
	return ApiIamOrganisationServiceListRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

// Execute executes the request
//  @return []ResourceService
func (a *IamOrganisationApiService) IamOrganisationServiceListExecute(r ApiIamOrganisationServiceListRequest) ([]ResourceService, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ResourceService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationServiceList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/service"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationTransferAcceptRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	transferId string
	iamOrganisationTransferAccept *IamOrganisationTransferAccept
}

func (r ApiIamOrganisationTransferAcceptRequest) IamOrganisationTransferAccept(iamOrganisationTransferAccept IamOrganisationTransferAccept) ApiIamOrganisationTransferAcceptRequest {
	r.iamOrganisationTransferAccept = &iamOrganisationTransferAccept
	return r
}

func (r ApiIamOrganisationTransferAcceptRequest) Execute() (*Transfer, *http.Response, error) {
	return r.ApiService.IamOrganisationTransferAcceptExecute(r)
}

/*
IamOrganisationTransferAccept Accept iam/organisation.transfer

action accept

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @param transferId transferId
 @return ApiIamOrganisationTransferAcceptRequest
*/
func (a *IamOrganisationApiService) IamOrganisationTransferAccept(ctx context.Context, organisationId string, transferId string) ApiIamOrganisationTransferAcceptRequest {
	return ApiIamOrganisationTransferAcceptRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		transferId: transferId,
	}
}

// Execute executes the request
//  @return Transfer
func (a *IamOrganisationApiService) IamOrganisationTransferAcceptExecute(r ApiIamOrganisationTransferAcceptRequest) (*Transfer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Transfer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationTransferAccept")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/transfer/{transferId}/actions/accept"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transferId"+"}", url.PathEscape(parameterToString(r.transferId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iamOrganisationTransferAccept == nil {
		return localVarReturnValue, nil, reportError("iamOrganisationTransferAccept is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iamOrganisationTransferAccept
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationTransferGetRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	transferId string
}


func (r ApiIamOrganisationTransferGetRequest) Execute() (*Transfer, *http.Response, error) {
	return r.ApiService.IamOrganisationTransferGetExecute(r)
}

/*
IamOrganisationTransferGet Get iam/organisation.transfer

Get iam/organisation.transfer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @param transferId transferId
 @return ApiIamOrganisationTransferGetRequest
*/
func (a *IamOrganisationApiService) IamOrganisationTransferGet(ctx context.Context, organisationId string, transferId string) ApiIamOrganisationTransferGetRequest {
	return ApiIamOrganisationTransferGetRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		transferId: transferId,
	}
}

// Execute executes the request
//  @return Transfer
func (a *IamOrganisationApiService) IamOrganisationTransferGetExecute(r ApiIamOrganisationTransferGetRequest) (*Transfer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Transfer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationTransferGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/transfer/{transferId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transferId"+"}", url.PathEscape(parameterToString(r.transferId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationTransferListRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
}


func (r ApiIamOrganisationTransferListRequest) Execute() ([]Transfer, *http.Response, error) {
	return r.ApiService.IamOrganisationTransferListExecute(r)
}

/*
IamOrganisationTransferList List iam/organisation.transfer

List iam/organisation.transfer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @return ApiIamOrganisationTransferListRequest
*/
func (a *IamOrganisationApiService) IamOrganisationTransferList(ctx context.Context, organisationId string) ApiIamOrganisationTransferListRequest {
	return ApiIamOrganisationTransferListRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

// Execute executes the request
//  @return []Transfer
func (a *IamOrganisationApiService) IamOrganisationTransferListExecute(r ApiIamOrganisationTransferListRequest) ([]Transfer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Transfer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationTransferList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/transfer"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationUpdateRequest struct {
	ctx context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	iamOrganisationUpdate *IamOrganisationUpdate
}

func (r ApiIamOrganisationUpdateRequest) IamOrganisationUpdate(iamOrganisationUpdate IamOrganisationUpdate) ApiIamOrganisationUpdateRequest {
	r.iamOrganisationUpdate = &iamOrganisationUpdate
	return r
}

func (r ApiIamOrganisationUpdateRequest) Execute() (*Organisation, *http.Response, error) {
	return r.ApiService.IamOrganisationUpdateExecute(r)
}

/*
IamOrganisationUpdate Update iam/organisation

Returns modified organisation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organisationId Organisation Id
 @return ApiIamOrganisationUpdateRequest
*/
func (a *IamOrganisationApiService) IamOrganisationUpdate(ctx context.Context, organisationId string) ApiIamOrganisationUpdateRequest {
	return ApiIamOrganisationUpdateRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

// Execute executes the request
//  @return Organisation
func (a *IamOrganisationApiService) IamOrganisationUpdateExecute(r ApiIamOrganisationUpdateRequest) (*Organisation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Organisation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", url.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iamOrganisationUpdate == nil {
		return localVarReturnValue, nil, reportError("iamOrganisationUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iamOrganisationUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
