/*
 * HyperOne
 *
 * HyperOne API
 *
 * API version: 0.1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package h1

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"time"
	"os"
)

// Linger please
var (
	_ _context.Context
)

// IamOrganisationApiService IamOrganisationApi service
type IamOrganisationApiService service

type ApiIamOrganisationBillingListRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	start *time.Time
	end *time.Time
	resourceType *string
}

func (r ApiIamOrganisationBillingListRequest) Start(start time.Time) ApiIamOrganisationBillingListRequest {
	r.start = &start
	return r
}
func (r ApiIamOrganisationBillingListRequest) End(end time.Time) ApiIamOrganisationBillingListRequest {
	r.end = &end
	return r
}
func (r ApiIamOrganisationBillingListRequest) ResourceType(resourceType string) ApiIamOrganisationBillingListRequest {
	r.resourceType = &resourceType
	return r
}

func (r ApiIamOrganisationBillingListRequest) Execute() ([]Billing, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationBillingListExecute(r)
}

/*
 * IamOrganisationBillingList List iam/organisation.billing
 * List iam/organisation.billing
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @return ApiIamOrganisationBillingListRequest
 */
func (a *IamOrganisationApiService) IamOrganisationBillingList(ctx _context.Context, organisationId string) ApiIamOrganisationBillingListRequest {
	return ApiIamOrganisationBillingListRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

/*
 * Execute executes the request
 * @return []Billing
 */
func (a *IamOrganisationApiService) IamOrganisationBillingListExecute(r ApiIamOrganisationBillingListRequest) ([]Billing, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Billing
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationBillingList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/billing"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.resourceType != nil {
		localVarQueryParams.Add("resource.type", parameterToString(*r.resourceType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationCreateRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	iamOrganisationCreate *IamOrganisationCreate
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiIamOrganisationCreateRequest) IamOrganisationCreate(iamOrganisationCreate IamOrganisationCreate) ApiIamOrganisationCreateRequest {
	r.iamOrganisationCreate = &iamOrganisationCreate
	return r
}
func (r ApiIamOrganisationCreateRequest) XIdempotencyKey(xIdempotencyKey string) ApiIamOrganisationCreateRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
func (r ApiIamOrganisationCreateRequest) XDryRun(xDryRun string) ApiIamOrganisationCreateRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiIamOrganisationCreateRequest) Execute() (Organisation, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationCreateExecute(r)
}

/*
 * IamOrganisationCreate Create iam/organisation
 * Create organisation
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiIamOrganisationCreateRequest
 */
func (a *IamOrganisationApiService) IamOrganisationCreate(ctx _context.Context) ApiIamOrganisationCreateRequest {
	return ApiIamOrganisationCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return Organisation
 */
func (a *IamOrganisationApiService) IamOrganisationCreateExecute(r ApiIamOrganisationCreateRequest) (Organisation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Organisation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.iamOrganisationCreate == nil {
		return localVarReturnValue, nil, reportError("iamOrganisationCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	// body params
	localVarPostBody = r.iamOrganisationCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationDeleteRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
}


func (r ApiIamOrganisationDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IamOrganisationDeleteExecute(r)
}

/*
 * IamOrganisationDelete Delete iam/organisation
 * Delete organisation
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @return ApiIamOrganisationDeleteRequest
 */
func (a *IamOrganisationApiService) IamOrganisationDelete(ctx _context.Context, organisationId string) ApiIamOrganisationDeleteRequest {
	return ApiIamOrganisationDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

/*
 * Execute executes the request
 */
func (a *IamOrganisationApiService) IamOrganisationDeleteExecute(r ApiIamOrganisationDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIamOrganisationEventGetRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	eventId string
}


func (r ApiIamOrganisationEventGetRequest) Execute() (Event, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationEventGetExecute(r)
}

/*
 * IamOrganisationEventGet Get iam/organisation.event
 * Get iam/organisation.event
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param eventId eventId
 * @return ApiIamOrganisationEventGetRequest
 */
func (a *IamOrganisationApiService) IamOrganisationEventGet(ctx _context.Context, organisationId string, eventId string) ApiIamOrganisationEventGetRequest {
	return ApiIamOrganisationEventGetRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		eventId: eventId,
	}
}

/*
 * Execute executes the request
 * @return Event
 */
func (a *IamOrganisationApiService) IamOrganisationEventGetExecute(r ApiIamOrganisationEventGetRequest) (Event, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationEventGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/event/{eventId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationEventListRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	limit *float32
	skip *float32
}

func (r ApiIamOrganisationEventListRequest) Limit(limit float32) ApiIamOrganisationEventListRequest {
	r.limit = &limit
	return r
}
func (r ApiIamOrganisationEventListRequest) Skip(skip float32) ApiIamOrganisationEventListRequest {
	r.skip = &skip
	return r
}

func (r ApiIamOrganisationEventListRequest) Execute() ([]Event, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationEventListExecute(r)
}

/*
 * IamOrganisationEventList List iam/organisation.event
 * List iam/organisation.event
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @return ApiIamOrganisationEventListRequest
 */
func (a *IamOrganisationApiService) IamOrganisationEventList(ctx _context.Context, organisationId string) ApiIamOrganisationEventListRequest {
	return ApiIamOrganisationEventListRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

/*
 * Execute executes the request
 * @return []Event
 */
func (a *IamOrganisationApiService) IamOrganisationEventListExecute(r ApiIamOrganisationEventListRequest) ([]Event, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationEventList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/event"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("$limit", parameterToString(*r.limit, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationGetRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
}


func (r ApiIamOrganisationGetRequest) Execute() (Organisation, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationGetExecute(r)
}

/*
 * IamOrganisationGet Get iam/organisation
 * Returns a single organisation
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @return ApiIamOrganisationGetRequest
 */
func (a *IamOrganisationApiService) IamOrganisationGet(ctx _context.Context, organisationId string) ApiIamOrganisationGetRequest {
	return ApiIamOrganisationGetRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

/*
 * Execute executes the request
 * @return Organisation
 */
func (a *IamOrganisationApiService) IamOrganisationGetExecute(r ApiIamOrganisationGetRequest) (Organisation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Organisation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationInvitationAcceptRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	invitationId string
	iamOrganisationInvitationAccept *IamOrganisationInvitationAccept
}

func (r ApiIamOrganisationInvitationAcceptRequest) IamOrganisationInvitationAccept(iamOrganisationInvitationAccept IamOrganisationInvitationAccept) ApiIamOrganisationInvitationAcceptRequest {
	r.iamOrganisationInvitationAccept = &iamOrganisationInvitationAccept
	return r
}

func (r ApiIamOrganisationInvitationAcceptRequest) Execute() (Invitation, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationInvitationAcceptExecute(r)
}

/*
 * IamOrganisationInvitationAccept Accept iam/organisation.invitation
 * action accept
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param invitationId invitationId
 * @return ApiIamOrganisationInvitationAcceptRequest
 */
func (a *IamOrganisationApiService) IamOrganisationInvitationAccept(ctx _context.Context, organisationId string, invitationId string) ApiIamOrganisationInvitationAcceptRequest {
	return ApiIamOrganisationInvitationAcceptRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		invitationId: invitationId,
	}
}

/*
 * Execute executes the request
 * @return Invitation
 */
func (a *IamOrganisationApiService) IamOrganisationInvitationAcceptExecute(r ApiIamOrganisationInvitationAcceptRequest) (Invitation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Invitation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationInvitationAccept")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/invitation/{invitationId}/actions/accept"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invitationId"+"}", _neturl.PathEscape(parameterToString(r.invitationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.iamOrganisationInvitationAccept == nil {
		return localVarReturnValue, nil, reportError("iamOrganisationInvitationAccept is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iamOrganisationInvitationAccept
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationInvitationDeleteRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	invitationId string
}


func (r ApiIamOrganisationInvitationDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IamOrganisationInvitationDeleteExecute(r)
}

/*
 * IamOrganisationInvitationDelete Delete iam/organisation.invitation
 * Delete iam/organisation.invitation
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param invitationId invitationId
 * @return ApiIamOrganisationInvitationDeleteRequest
 */
func (a *IamOrganisationApiService) IamOrganisationInvitationDelete(ctx _context.Context, organisationId string, invitationId string) ApiIamOrganisationInvitationDeleteRequest {
	return ApiIamOrganisationInvitationDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		invitationId: invitationId,
	}
}

/*
 * Execute executes the request
 */
func (a *IamOrganisationApiService) IamOrganisationInvitationDeleteExecute(r ApiIamOrganisationInvitationDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationInvitationDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/invitation/{invitationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invitationId"+"}", _neturl.PathEscape(parameterToString(r.invitationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIamOrganisationInvitationGetRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	invitationId string
}


func (r ApiIamOrganisationInvitationGetRequest) Execute() (Invitation, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationInvitationGetExecute(r)
}

/*
 * IamOrganisationInvitationGet Get iam/organisation.invitation
 * Get iam/organisation.invitation
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param invitationId invitationId
 * @return ApiIamOrganisationInvitationGetRequest
 */
func (a *IamOrganisationApiService) IamOrganisationInvitationGet(ctx _context.Context, organisationId string, invitationId string) ApiIamOrganisationInvitationGetRequest {
	return ApiIamOrganisationInvitationGetRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		invitationId: invitationId,
	}
}

/*
 * Execute executes the request
 * @return Invitation
 */
func (a *IamOrganisationApiService) IamOrganisationInvitationGetExecute(r ApiIamOrganisationInvitationGetRequest) (Invitation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Invitation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationInvitationGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/invitation/{invitationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invitationId"+"}", _neturl.PathEscape(parameterToString(r.invitationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationInvitationListRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	resource *string
}

func (r ApiIamOrganisationInvitationListRequest) Resource(resource string) ApiIamOrganisationInvitationListRequest {
	r.resource = &resource
	return r
}

func (r ApiIamOrganisationInvitationListRequest) Execute() ([]Invitation, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationInvitationListExecute(r)
}

/*
 * IamOrganisationInvitationList List iam/organisation.invitation
 * List iam/organisation.invitation
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @return ApiIamOrganisationInvitationListRequest
 */
func (a *IamOrganisationApiService) IamOrganisationInvitationList(ctx _context.Context, organisationId string) ApiIamOrganisationInvitationListRequest {
	return ApiIamOrganisationInvitationListRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

/*
 * Execute executes the request
 * @return []Invitation
 */
func (a *IamOrganisationApiService) IamOrganisationInvitationListExecute(r ApiIamOrganisationInvitationListRequest) ([]Invitation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Invitation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationInvitationList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/invitation"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.resource != nil {
		localVarQueryParams.Add("resource", parameterToString(*r.resource, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationInvoiceDownloadRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	invoiceId string
}


func (r ApiIamOrganisationInvoiceDownloadRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationInvoiceDownloadExecute(r)
}

/*
 * IamOrganisationInvoiceDownload Download iam/organisation.invoice
 * action download
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param invoiceId invoiceId
 * @return ApiIamOrganisationInvoiceDownloadRequest
 */
func (a *IamOrganisationApiService) IamOrganisationInvoiceDownload(ctx _context.Context, organisationId string, invoiceId string) ApiIamOrganisationInvoiceDownloadRequest {
	return ApiIamOrganisationInvoiceDownloadRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		invoiceId: invoiceId,
	}
}

/*
 * Execute executes the request
 * @return *os.File
 */
func (a *IamOrganisationApiService) IamOrganisationInvoiceDownloadExecute(r ApiIamOrganisationInvoiceDownloadRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationInvoiceDownload")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/invoice/{invoiceId}/actions/download"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", _neturl.PathEscape(parameterToString(r.invoiceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/pdf", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationInvoiceGetRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	invoiceId string
}


func (r ApiIamOrganisationInvoiceGetRequest) Execute() (Invoice, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationInvoiceGetExecute(r)
}

/*
 * IamOrganisationInvoiceGet Get iam/organisation.invoice
 * Get iam/organisation.invoice
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param invoiceId invoiceId
 * @return ApiIamOrganisationInvoiceGetRequest
 */
func (a *IamOrganisationApiService) IamOrganisationInvoiceGet(ctx _context.Context, organisationId string, invoiceId string) ApiIamOrganisationInvoiceGetRequest {
	return ApiIamOrganisationInvoiceGetRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		invoiceId: invoiceId,
	}
}

/*
 * Execute executes the request
 * @return Invoice
 */
func (a *IamOrganisationApiService) IamOrganisationInvoiceGetExecute(r ApiIamOrganisationInvoiceGetRequest) (Invoice, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Invoice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationInvoiceGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/invoice/{invoiceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceId"+"}", _neturl.PathEscape(parameterToString(r.invoiceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationInvoiceListRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
}


func (r ApiIamOrganisationInvoiceListRequest) Execute() ([]Invoice, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationInvoiceListExecute(r)
}

/*
 * IamOrganisationInvoiceList List iam/organisation.invoice
 * List iam/organisation.invoice
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @return ApiIamOrganisationInvoiceListRequest
 */
func (a *IamOrganisationApiService) IamOrganisationInvoiceList(ctx _context.Context, organisationId string) ApiIamOrganisationInvoiceListRequest {
	return ApiIamOrganisationInvoiceListRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

/*
 * Execute executes the request
 * @return []Invoice
 */
func (a *IamOrganisationApiService) IamOrganisationInvoiceListExecute(r ApiIamOrganisationInvoiceListRequest) ([]Invoice, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Invoice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationInvoiceList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/invoice"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationListRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	name *string
	billingCompany *string
	limit *float32
	active *bool
}

func (r ApiIamOrganisationListRequest) Name(name string) ApiIamOrganisationListRequest {
	r.name = &name
	return r
}
func (r ApiIamOrganisationListRequest) BillingCompany(billingCompany string) ApiIamOrganisationListRequest {
	r.billingCompany = &billingCompany
	return r
}
func (r ApiIamOrganisationListRequest) Limit(limit float32) ApiIamOrganisationListRequest {
	r.limit = &limit
	return r
}
func (r ApiIamOrganisationListRequest) Active(active bool) ApiIamOrganisationListRequest {
	r.active = &active
	return r
}

func (r ApiIamOrganisationListRequest) Execute() ([]Organisation, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationListExecute(r)
}

/*
 * IamOrganisationList List iam/organisation
 * List organisation
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiIamOrganisationListRequest
 */
func (a *IamOrganisationApiService) IamOrganisationList(ctx _context.Context) ApiIamOrganisationListRequest {
	return ApiIamOrganisationListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return []Organisation
 */
func (a *IamOrganisationApiService) IamOrganisationListExecute(r ApiIamOrganisationListRequest) ([]Organisation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Organisation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.billingCompany != nil {
		localVarQueryParams.Add("billing.company", parameterToString(*r.billingCompany, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("$limit", parameterToString(*r.limit, ""))
	}
	if r.active != nil {
		localVarQueryParams.Add("active", parameterToString(*r.active, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationOwnershipCreateRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	iamOrganisationOwnershipCreate *IamOrganisationOwnershipCreate
}

func (r ApiIamOrganisationOwnershipCreateRequest) IamOrganisationOwnershipCreate(iamOrganisationOwnershipCreate IamOrganisationOwnershipCreate) ApiIamOrganisationOwnershipCreateRequest {
	r.iamOrganisationOwnershipCreate = &iamOrganisationOwnershipCreate
	return r
}

func (r ApiIamOrganisationOwnershipCreateRequest) Execute() (Organisation, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationOwnershipCreateExecute(r)
}

/*
 * IamOrganisationOwnershipCreate Create iam/organisation.ownership
 * Create iam/organisation.ownership
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @return ApiIamOrganisationOwnershipCreateRequest
 */
func (a *IamOrganisationApiService) IamOrganisationOwnershipCreate(ctx _context.Context, organisationId string) ApiIamOrganisationOwnershipCreateRequest {
	return ApiIamOrganisationOwnershipCreateRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

/*
 * Execute executes the request
 * @return Organisation
 */
func (a *IamOrganisationApiService) IamOrganisationOwnershipCreateExecute(r ApiIamOrganisationOwnershipCreateRequest) (Organisation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Organisation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationOwnershipCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/ownership"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.iamOrganisationOwnershipCreate == nil {
		return localVarReturnValue, nil, reportError("iamOrganisationOwnershipCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iamOrganisationOwnershipCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationOwnershipDeleteRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	ownershipId string
}


func (r ApiIamOrganisationOwnershipDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IamOrganisationOwnershipDeleteExecute(r)
}

/*
 * IamOrganisationOwnershipDelete Delete iam/organisation.ownership
 * Delete iam/organisation.ownership
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param ownershipId ownershipId
 * @return ApiIamOrganisationOwnershipDeleteRequest
 */
func (a *IamOrganisationApiService) IamOrganisationOwnershipDelete(ctx _context.Context, organisationId string, ownershipId string) ApiIamOrganisationOwnershipDeleteRequest {
	return ApiIamOrganisationOwnershipDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		ownershipId: ownershipId,
	}
}

/*
 * Execute executes the request
 */
func (a *IamOrganisationApiService) IamOrganisationOwnershipDeleteExecute(r ApiIamOrganisationOwnershipDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationOwnershipDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/ownership/{ownershipId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ownershipId"+"}", _neturl.PathEscape(parameterToString(r.ownershipId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIamOrganisationOwnershipGetRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	ownershipId string
}


func (r ApiIamOrganisationOwnershipGetRequest) Execute() (Ownership, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationOwnershipGetExecute(r)
}

/*
 * IamOrganisationOwnershipGet Get iam/organisation.ownership
 * Get iam/organisation.ownership
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param ownershipId ownershipId
 * @return ApiIamOrganisationOwnershipGetRequest
 */
func (a *IamOrganisationApiService) IamOrganisationOwnershipGet(ctx _context.Context, organisationId string, ownershipId string) ApiIamOrganisationOwnershipGetRequest {
	return ApiIamOrganisationOwnershipGetRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		ownershipId: ownershipId,
	}
}

/*
 * Execute executes the request
 * @return Ownership
 */
func (a *IamOrganisationApiService) IamOrganisationOwnershipGetExecute(r ApiIamOrganisationOwnershipGetRequest) (Ownership, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Ownership
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationOwnershipGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/ownership/{ownershipId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ownershipId"+"}", _neturl.PathEscape(parameterToString(r.ownershipId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationOwnershipListRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
}


func (r ApiIamOrganisationOwnershipListRequest) Execute() ([]Ownership, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationOwnershipListExecute(r)
}

/*
 * IamOrganisationOwnershipList List iam/organisation.ownership
 * List iam/organisation.ownership
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @return ApiIamOrganisationOwnershipListRequest
 */
func (a *IamOrganisationApiService) IamOrganisationOwnershipList(ctx _context.Context, organisationId string) ApiIamOrganisationOwnershipListRequest {
	return ApiIamOrganisationOwnershipListRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

/*
 * Execute executes the request
 * @return []Ownership
 */
func (a *IamOrganisationApiService) IamOrganisationOwnershipListExecute(r ApiIamOrganisationOwnershipListRequest) ([]Ownership, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Ownership
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationOwnershipList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/ownership"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationPaymentAllocateRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	paymentId string
	iamOrganisationPaymentAllocate *IamOrganisationPaymentAllocate
}

func (r ApiIamOrganisationPaymentAllocateRequest) IamOrganisationPaymentAllocate(iamOrganisationPaymentAllocate IamOrganisationPaymentAllocate) ApiIamOrganisationPaymentAllocateRequest {
	r.iamOrganisationPaymentAllocate = &iamOrganisationPaymentAllocate
	return r
}

func (r ApiIamOrganisationPaymentAllocateRequest) Execute() (Payment, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationPaymentAllocateExecute(r)
}

/*
 * IamOrganisationPaymentAllocate Allocate iam/organisation.payment
 * action allocate
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param paymentId paymentId
 * @return ApiIamOrganisationPaymentAllocateRequest
 */
func (a *IamOrganisationApiService) IamOrganisationPaymentAllocate(ctx _context.Context, organisationId string, paymentId string) ApiIamOrganisationPaymentAllocateRequest {
	return ApiIamOrganisationPaymentAllocateRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		paymentId: paymentId,
	}
}

/*
 * Execute executes the request
 * @return Payment
 */
func (a *IamOrganisationApiService) IamOrganisationPaymentAllocateExecute(r ApiIamOrganisationPaymentAllocateRequest) (Payment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Payment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationPaymentAllocate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/payment/{paymentId}/actions/allocate"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"paymentId"+"}", _neturl.PathEscape(parameterToString(r.paymentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.iamOrganisationPaymentAllocate == nil {
		return localVarReturnValue, nil, reportError("iamOrganisationPaymentAllocate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iamOrganisationPaymentAllocate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationPaymentGetRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	paymentId string
}


func (r ApiIamOrganisationPaymentGetRequest) Execute() (Payment, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationPaymentGetExecute(r)
}

/*
 * IamOrganisationPaymentGet Get iam/organisation.payment
 * Get iam/organisation.payment
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param paymentId paymentId
 * @return ApiIamOrganisationPaymentGetRequest
 */
func (a *IamOrganisationApiService) IamOrganisationPaymentGet(ctx _context.Context, organisationId string, paymentId string) ApiIamOrganisationPaymentGetRequest {
	return ApiIamOrganisationPaymentGetRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		paymentId: paymentId,
	}
}

/*
 * Execute executes the request
 * @return Payment
 */
func (a *IamOrganisationApiService) IamOrganisationPaymentGetExecute(r ApiIamOrganisationPaymentGetRequest) (Payment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Payment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationPaymentGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/payment/{paymentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"paymentId"+"}", _neturl.PathEscape(parameterToString(r.paymentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationPaymentListRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
}


func (r ApiIamOrganisationPaymentListRequest) Execute() ([]Payment, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationPaymentListExecute(r)
}

/*
 * IamOrganisationPaymentList List iam/organisation.payment
 * List iam/organisation.payment
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @return ApiIamOrganisationPaymentListRequest
 */
func (a *IamOrganisationApiService) IamOrganisationPaymentList(ctx _context.Context, organisationId string) ApiIamOrganisationPaymentListRequest {
	return ApiIamOrganisationPaymentListRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

/*
 * Execute executes the request
 * @return []Payment
 */
func (a *IamOrganisationApiService) IamOrganisationPaymentListExecute(r ApiIamOrganisationPaymentListRequest) ([]Payment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Payment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationPaymentList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/payment"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationProformaCreateRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	iamOrganisationProformaCreate *IamOrganisationProformaCreate
}

func (r ApiIamOrganisationProformaCreateRequest) IamOrganisationProformaCreate(iamOrganisationProformaCreate IamOrganisationProformaCreate) ApiIamOrganisationProformaCreateRequest {
	r.iamOrganisationProformaCreate = &iamOrganisationProformaCreate
	return r
}

func (r ApiIamOrganisationProformaCreateRequest) Execute() (Proforma, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationProformaCreateExecute(r)
}

/*
 * IamOrganisationProformaCreate Create iam/organisation.proforma
 * Create iam/organisation.proforma
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @return ApiIamOrganisationProformaCreateRequest
 */
func (a *IamOrganisationApiService) IamOrganisationProformaCreate(ctx _context.Context, organisationId string) ApiIamOrganisationProformaCreateRequest {
	return ApiIamOrganisationProformaCreateRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

/*
 * Execute executes the request
 * @return Proforma
 */
func (a *IamOrganisationApiService) IamOrganisationProformaCreateExecute(r ApiIamOrganisationProformaCreateRequest) (Proforma, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Proforma
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationProformaCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/proforma"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.iamOrganisationProformaCreate == nil {
		return localVarReturnValue, nil, reportError("iamOrganisationProformaCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iamOrganisationProformaCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationProformaDownloadRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	proformaId string
}


func (r ApiIamOrganisationProformaDownloadRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationProformaDownloadExecute(r)
}

/*
 * IamOrganisationProformaDownload Download iam/organisation.proforma
 * action download
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param proformaId proformaId
 * @return ApiIamOrganisationProformaDownloadRequest
 */
func (a *IamOrganisationApiService) IamOrganisationProformaDownload(ctx _context.Context, organisationId string, proformaId string) ApiIamOrganisationProformaDownloadRequest {
	return ApiIamOrganisationProformaDownloadRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		proformaId: proformaId,
	}
}

/*
 * Execute executes the request
 * @return *os.File
 */
func (a *IamOrganisationApiService) IamOrganisationProformaDownloadExecute(r ApiIamOrganisationProformaDownloadRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationProformaDownload")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/proforma/{proformaId}/actions/download"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"proformaId"+"}", _neturl.PathEscape(parameterToString(r.proformaId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/pdf", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationProformaGetRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	proformaId string
}


func (r ApiIamOrganisationProformaGetRequest) Execute() (Proforma, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationProformaGetExecute(r)
}

/*
 * IamOrganisationProformaGet Get iam/organisation.proforma
 * Get iam/organisation.proforma
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param proformaId proformaId
 * @return ApiIamOrganisationProformaGetRequest
 */
func (a *IamOrganisationApiService) IamOrganisationProformaGet(ctx _context.Context, organisationId string, proformaId string) ApiIamOrganisationProformaGetRequest {
	return ApiIamOrganisationProformaGetRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		proformaId: proformaId,
	}
}

/*
 * Execute executes the request
 * @return Proforma
 */
func (a *IamOrganisationApiService) IamOrganisationProformaGetExecute(r ApiIamOrganisationProformaGetRequest) (Proforma, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Proforma
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationProformaGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/proforma/{proformaId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"proformaId"+"}", _neturl.PathEscape(parameterToString(r.proformaId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationProformaListRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
}


func (r ApiIamOrganisationProformaListRequest) Execute() ([]Proforma, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationProformaListExecute(r)
}

/*
 * IamOrganisationProformaList List iam/organisation.proforma
 * List iam/organisation.proforma
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @return ApiIamOrganisationProformaListRequest
 */
func (a *IamOrganisationApiService) IamOrganisationProformaList(ctx _context.Context, organisationId string) ApiIamOrganisationProformaListRequest {
	return ApiIamOrganisationProformaListRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

/*
 * Execute executes the request
 * @return []Proforma
 */
func (a *IamOrganisationApiService) IamOrganisationProformaListExecute(r ApiIamOrganisationProformaListRequest) ([]Proforma, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Proforma
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationProformaList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/proforma"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationServiceGetRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	serviceId string
}


func (r ApiIamOrganisationServiceGetRequest) Execute() (ResourceService, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationServiceGetExecute(r)
}

/*
 * IamOrganisationServiceGet Get iam/organisation.service
 * Get iam/organisation.service
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param serviceId serviceId
 * @return ApiIamOrganisationServiceGetRequest
 */
func (a *IamOrganisationApiService) IamOrganisationServiceGet(ctx _context.Context, organisationId string, serviceId string) ApiIamOrganisationServiceGetRequest {
	return ApiIamOrganisationServiceGetRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		serviceId: serviceId,
	}
}

/*
 * Execute executes the request
 * @return ResourceService
 */
func (a *IamOrganisationApiService) IamOrganisationServiceGetExecute(r ApiIamOrganisationServiceGetRequest) (ResourceService, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResourceService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationServiceGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/service/{serviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serviceId"+"}", _neturl.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationServiceListRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
}


func (r ApiIamOrganisationServiceListRequest) Execute() ([]ResourceService, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationServiceListExecute(r)
}

/*
 * IamOrganisationServiceList List iam/organisation.service
 * List iam/organisation.service
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @return ApiIamOrganisationServiceListRequest
 */
func (a *IamOrganisationApiService) IamOrganisationServiceList(ctx _context.Context, organisationId string) ApiIamOrganisationServiceListRequest {
	return ApiIamOrganisationServiceListRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

/*
 * Execute executes the request
 * @return []ResourceService
 */
func (a *IamOrganisationApiService) IamOrganisationServiceListExecute(r ApiIamOrganisationServiceListRequest) ([]ResourceService, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ResourceService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationServiceList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/service"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationTransferAcceptRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	transferId string
	iamOrganisationTransferAccept *IamOrganisationTransferAccept
}

func (r ApiIamOrganisationTransferAcceptRequest) IamOrganisationTransferAccept(iamOrganisationTransferAccept IamOrganisationTransferAccept) ApiIamOrganisationTransferAcceptRequest {
	r.iamOrganisationTransferAccept = &iamOrganisationTransferAccept
	return r
}

func (r ApiIamOrganisationTransferAcceptRequest) Execute() (Transfer, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationTransferAcceptExecute(r)
}

/*
 * IamOrganisationTransferAccept Accept iam/organisation.transfer
 * action accept
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param transferId transferId
 * @return ApiIamOrganisationTransferAcceptRequest
 */
func (a *IamOrganisationApiService) IamOrganisationTransferAccept(ctx _context.Context, organisationId string, transferId string) ApiIamOrganisationTransferAcceptRequest {
	return ApiIamOrganisationTransferAcceptRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		transferId: transferId,
	}
}

/*
 * Execute executes the request
 * @return Transfer
 */
func (a *IamOrganisationApiService) IamOrganisationTransferAcceptExecute(r ApiIamOrganisationTransferAcceptRequest) (Transfer, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Transfer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationTransferAccept")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/transfer/{transferId}/actions/accept"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transferId"+"}", _neturl.PathEscape(parameterToString(r.transferId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.iamOrganisationTransferAccept == nil {
		return localVarReturnValue, nil, reportError("iamOrganisationTransferAccept is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iamOrganisationTransferAccept
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationTransferGetRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	transferId string
}


func (r ApiIamOrganisationTransferGetRequest) Execute() (Transfer, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationTransferGetExecute(r)
}

/*
 * IamOrganisationTransferGet Get iam/organisation.transfer
 * Get iam/organisation.transfer
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param transferId transferId
 * @return ApiIamOrganisationTransferGetRequest
 */
func (a *IamOrganisationApiService) IamOrganisationTransferGet(ctx _context.Context, organisationId string, transferId string) ApiIamOrganisationTransferGetRequest {
	return ApiIamOrganisationTransferGetRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		transferId: transferId,
	}
}

/*
 * Execute executes the request
 * @return Transfer
 */
func (a *IamOrganisationApiService) IamOrganisationTransferGetExecute(r ApiIamOrganisationTransferGetRequest) (Transfer, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Transfer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationTransferGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/transfer/{transferId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transferId"+"}", _neturl.PathEscape(parameterToString(r.transferId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationTransferListRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
}


func (r ApiIamOrganisationTransferListRequest) Execute() ([]Transfer, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationTransferListExecute(r)
}

/*
 * IamOrganisationTransferList List iam/organisation.transfer
 * List iam/organisation.transfer
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @return ApiIamOrganisationTransferListRequest
 */
func (a *IamOrganisationApiService) IamOrganisationTransferList(ctx _context.Context, organisationId string) ApiIamOrganisationTransferListRequest {
	return ApiIamOrganisationTransferListRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

/*
 * Execute executes the request
 * @return []Transfer
 */
func (a *IamOrganisationApiService) IamOrganisationTransferListExecute(r ApiIamOrganisationTransferListRequest) ([]Transfer, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Transfer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationTransferList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/transfer"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationUpdateRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationApiService
	organisationId string
	iamOrganisationUpdate *IamOrganisationUpdate
}

func (r ApiIamOrganisationUpdateRequest) IamOrganisationUpdate(iamOrganisationUpdate IamOrganisationUpdate) ApiIamOrganisationUpdateRequest {
	r.iamOrganisationUpdate = &iamOrganisationUpdate
	return r
}

func (r ApiIamOrganisationUpdateRequest) Execute() (Organisation, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationUpdateExecute(r)
}

/*
 * IamOrganisationUpdate Update iam/organisation
 * Returns modified organisation
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @return ApiIamOrganisationUpdateRequest
 */
func (a *IamOrganisationApiService) IamOrganisationUpdate(ctx _context.Context, organisationId string) ApiIamOrganisationUpdateRequest {
	return ApiIamOrganisationUpdateRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

/*
 * Execute executes the request
 * @return Organisation
 */
func (a *IamOrganisationApiService) IamOrganisationUpdateExecute(r ApiIamOrganisationUpdateRequest) (Organisation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Organisation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationApiService.IamOrganisationUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.iamOrganisationUpdate == nil {
		return localVarReturnValue, nil, reportError("iamOrganisationUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iamOrganisationUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
