/*
 * HyperOne
 *
 * HyperOne API
 *
 * API version: 0.1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package h1

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// NetworkingProjectNetadpApiService NetworkingProjectNetadpApi service
type NetworkingProjectNetadpApiService service

type ApiNetworkingProjectNetadpCreateRequest struct {
	ctx _context.Context
	ApiService *NetworkingProjectNetadpApiService
	projectId string
	locationId string
	networkingProjectNetadpCreate *NetworkingProjectNetadpCreate
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiNetworkingProjectNetadpCreateRequest) NetworkingProjectNetadpCreate(networkingProjectNetadpCreate NetworkingProjectNetadpCreate) ApiNetworkingProjectNetadpCreateRequest {
	r.networkingProjectNetadpCreate = &networkingProjectNetadpCreate
	return r
}
func (r ApiNetworkingProjectNetadpCreateRequest) XIdempotencyKey(xIdempotencyKey string) ApiNetworkingProjectNetadpCreateRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
func (r ApiNetworkingProjectNetadpCreateRequest) XDryRun(xDryRun string) ApiNetworkingProjectNetadpCreateRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiNetworkingProjectNetadpCreateRequest) Execute() (Netadp, *_nethttp.Response, error) {
	return r.ApiService.NetworkingProjectNetadpCreateExecute(r)
}

/*
 * NetworkingProjectNetadpCreate Create networking/netadp
 * Create netadp
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @return ApiNetworkingProjectNetadpCreateRequest
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpCreate(ctx _context.Context, projectId string, locationId string) ApiNetworkingProjectNetadpCreateRequest {
	return ApiNetworkingProjectNetadpCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
	}
}

/*
 * Execute executes the request
 * @return Netadp
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpCreateExecute(r ApiNetworkingProjectNetadpCreateRequest) (Netadp, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Netadp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetadpApiService.NetworkingProjectNetadpCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netadp"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.networkingProjectNetadpCreate == nil {
		return localVarReturnValue, nil, reportError("networkingProjectNetadpCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	// body params
	localVarPostBody = r.networkingProjectNetadpCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetadpDeleteRequest struct {
	ctx _context.Context
	ApiService *NetworkingProjectNetadpApiService
	projectId string
	locationId string
	netadpId string
}


func (r ApiNetworkingProjectNetadpDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.NetworkingProjectNetadpDeleteExecute(r)
}

/*
 * NetworkingProjectNetadpDelete Delete networking/netadp
 * Delete netadp
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param netadpId Netadp Id
 * @return ApiNetworkingProjectNetadpDeleteRequest
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpDelete(ctx _context.Context, projectId string, locationId string, netadpId string) ApiNetworkingProjectNetadpDeleteRequest {
	return ApiNetworkingProjectNetadpDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netadpId: netadpId,
	}
}

/*
 * Execute executes the request
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpDeleteExecute(r ApiNetworkingProjectNetadpDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetadpApiService.NetworkingProjectNetadpDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netadp/{netadpId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netadpId"+"}", _neturl.PathEscape(parameterToString(r.netadpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetadpEventGetRequest struct {
	ctx _context.Context
	ApiService *NetworkingProjectNetadpApiService
	projectId string
	locationId string
	netadpId string
	eventId string
}


func (r ApiNetworkingProjectNetadpEventGetRequest) Execute() (Event, *_nethttp.Response, error) {
	return r.ApiService.NetworkingProjectNetadpEventGetExecute(r)
}

/*
 * NetworkingProjectNetadpEventGet Get networking/netadp.event
 * Get networking/netadp.event
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param netadpId Netadp Id
 * @param eventId eventId
 * @return ApiNetworkingProjectNetadpEventGetRequest
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpEventGet(ctx _context.Context, projectId string, locationId string, netadpId string, eventId string) ApiNetworkingProjectNetadpEventGetRequest {
	return ApiNetworkingProjectNetadpEventGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netadpId: netadpId,
		eventId: eventId,
	}
}

/*
 * Execute executes the request
 * @return Event
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpEventGetExecute(r ApiNetworkingProjectNetadpEventGetRequest) (Event, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetadpApiService.NetworkingProjectNetadpEventGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netadp/{netadpId}/event/{eventId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netadpId"+"}", _neturl.PathEscape(parameterToString(r.netadpId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetadpEventListRequest struct {
	ctx _context.Context
	ApiService *NetworkingProjectNetadpApiService
	projectId string
	locationId string
	netadpId string
	limit *float32
	skip *float32
}

func (r ApiNetworkingProjectNetadpEventListRequest) Limit(limit float32) ApiNetworkingProjectNetadpEventListRequest {
	r.limit = &limit
	return r
}
func (r ApiNetworkingProjectNetadpEventListRequest) Skip(skip float32) ApiNetworkingProjectNetadpEventListRequest {
	r.skip = &skip
	return r
}

func (r ApiNetworkingProjectNetadpEventListRequest) Execute() ([]Event, *_nethttp.Response, error) {
	return r.ApiService.NetworkingProjectNetadpEventListExecute(r)
}

/*
 * NetworkingProjectNetadpEventList List networking/netadp.event
 * List networking/netadp.event
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param netadpId Netadp Id
 * @return ApiNetworkingProjectNetadpEventListRequest
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpEventList(ctx _context.Context, projectId string, locationId string, netadpId string) ApiNetworkingProjectNetadpEventListRequest {
	return ApiNetworkingProjectNetadpEventListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netadpId: netadpId,
	}
}

/*
 * Execute executes the request
 * @return []Event
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpEventListExecute(r ApiNetworkingProjectNetadpEventListRequest) ([]Event, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetadpApiService.NetworkingProjectNetadpEventList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netadp/{netadpId}/event"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netadpId"+"}", _neturl.PathEscape(parameterToString(r.netadpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("$limit", parameterToString(*r.limit, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetadpGetRequest struct {
	ctx _context.Context
	ApiService *NetworkingProjectNetadpApiService
	projectId string
	locationId string
	netadpId string
}


func (r ApiNetworkingProjectNetadpGetRequest) Execute() (Netadp, *_nethttp.Response, error) {
	return r.ApiService.NetworkingProjectNetadpGetExecute(r)
}

/*
 * NetworkingProjectNetadpGet Get networking/netadp
 * Returns a single netadp
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param netadpId Netadp Id
 * @return ApiNetworkingProjectNetadpGetRequest
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpGet(ctx _context.Context, projectId string, locationId string, netadpId string) ApiNetworkingProjectNetadpGetRequest {
	return ApiNetworkingProjectNetadpGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netadpId: netadpId,
	}
}

/*
 * Execute executes the request
 * @return Netadp
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpGetExecute(r ApiNetworkingProjectNetadpGetRequest) (Netadp, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Netadp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetadpApiService.NetworkingProjectNetadpGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netadp/{netadpId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netadpId"+"}", _neturl.PathEscape(parameterToString(r.netadpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetadpListRequest struct {
	ctx _context.Context
	ApiService *NetworkingProjectNetadpApiService
	projectId string
	locationId string
	assignedResource *string
	assignedId *string
	network *string
	tagValue *string
	tagKey *string
}

func (r ApiNetworkingProjectNetadpListRequest) AssignedResource(assignedResource string) ApiNetworkingProjectNetadpListRequest {
	r.assignedResource = &assignedResource
	return r
}
func (r ApiNetworkingProjectNetadpListRequest) AssignedId(assignedId string) ApiNetworkingProjectNetadpListRequest {
	r.assignedId = &assignedId
	return r
}
func (r ApiNetworkingProjectNetadpListRequest) Network(network string) ApiNetworkingProjectNetadpListRequest {
	r.network = &network
	return r
}
func (r ApiNetworkingProjectNetadpListRequest) TagValue(tagValue string) ApiNetworkingProjectNetadpListRequest {
	r.tagValue = &tagValue
	return r
}
func (r ApiNetworkingProjectNetadpListRequest) TagKey(tagKey string) ApiNetworkingProjectNetadpListRequest {
	r.tagKey = &tagKey
	return r
}

func (r ApiNetworkingProjectNetadpListRequest) Execute() ([]Netadp, *_nethttp.Response, error) {
	return r.ApiService.NetworkingProjectNetadpListExecute(r)
}

/*
 * NetworkingProjectNetadpList List networking/netadp
 * List netadp
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @return ApiNetworkingProjectNetadpListRequest
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpList(ctx _context.Context, projectId string, locationId string) ApiNetworkingProjectNetadpListRequest {
	return ApiNetworkingProjectNetadpListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
	}
}

/*
 * Execute executes the request
 * @return []Netadp
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpListExecute(r ApiNetworkingProjectNetadpListRequest) ([]Netadp, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Netadp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetadpApiService.NetworkingProjectNetadpList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netadp"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.assignedResource != nil {
		localVarQueryParams.Add("assigned.resource", parameterToString(*r.assignedResource, ""))
	}
	if r.assignedId != nil {
		localVarQueryParams.Add("assigned.id", parameterToString(*r.assignedId, ""))
	}
	if r.network != nil {
		localVarQueryParams.Add("network", parameterToString(*r.network, ""))
	}
	if r.tagValue != nil {
		localVarQueryParams.Add("tag.value", parameterToString(*r.tagValue, ""))
	}
	if r.tagKey != nil {
		localVarQueryParams.Add("tag.key", parameterToString(*r.tagKey, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetadpMetricGetRequest struct {
	ctx _context.Context
	ApiService *NetworkingProjectNetadpApiService
	projectId string
	locationId string
	netadpId string
	metricId string
}


func (r ApiNetworkingProjectNetadpMetricGetRequest) Execute() (Metric, *_nethttp.Response, error) {
	return r.ApiService.NetworkingProjectNetadpMetricGetExecute(r)
}

/*
 * NetworkingProjectNetadpMetricGet Get networking/netadp.metric
 * Get networking/netadp.metric
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param netadpId Netadp Id
 * @param metricId metricId
 * @return ApiNetworkingProjectNetadpMetricGetRequest
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpMetricGet(ctx _context.Context, projectId string, locationId string, netadpId string, metricId string) ApiNetworkingProjectNetadpMetricGetRequest {
	return ApiNetworkingProjectNetadpMetricGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netadpId: netadpId,
		metricId: metricId,
	}
}

/*
 * Execute executes the request
 * @return Metric
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpMetricGetExecute(r ApiNetworkingProjectNetadpMetricGetRequest) (Metric, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Metric
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetadpApiService.NetworkingProjectNetadpMetricGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netadp/{netadpId}/metric/{metricId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netadpId"+"}", _neturl.PathEscape(parameterToString(r.netadpId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metricId"+"}", _neturl.PathEscape(parameterToString(r.metricId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetadpMetricListRequest struct {
	ctx _context.Context
	ApiService *NetworkingProjectNetadpApiService
	projectId string
	locationId string
	netadpId string
}


func (r ApiNetworkingProjectNetadpMetricListRequest) Execute() ([]Metric, *_nethttp.Response, error) {
	return r.ApiService.NetworkingProjectNetadpMetricListExecute(r)
}

/*
 * NetworkingProjectNetadpMetricList List networking/netadp.metric
 * List networking/netadp.metric
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param netadpId Netadp Id
 * @return ApiNetworkingProjectNetadpMetricListRequest
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpMetricList(ctx _context.Context, projectId string, locationId string, netadpId string) ApiNetworkingProjectNetadpMetricListRequest {
	return ApiNetworkingProjectNetadpMetricListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netadpId: netadpId,
	}
}

/*
 * Execute executes the request
 * @return []Metric
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpMetricListExecute(r ApiNetworkingProjectNetadpMetricListRequest) ([]Metric, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Metric
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetadpApiService.NetworkingProjectNetadpMetricList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netadp/{netadpId}/metric"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netadpId"+"}", _neturl.PathEscape(parameterToString(r.netadpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetadpMetricPointListRequest struct {
	ctx _context.Context
	ApiService *NetworkingProjectNetadpApiService
	projectId string
	locationId string
	netadpId string
	metricId string
	interval *string
	timespan *string
}

func (r ApiNetworkingProjectNetadpMetricPointListRequest) Interval(interval string) ApiNetworkingProjectNetadpMetricPointListRequest {
	r.interval = &interval
	return r
}
func (r ApiNetworkingProjectNetadpMetricPointListRequest) Timespan(timespan string) ApiNetworkingProjectNetadpMetricPointListRequest {
	r.timespan = &timespan
	return r
}

func (r ApiNetworkingProjectNetadpMetricPointListRequest) Execute() ([]Point, *_nethttp.Response, error) {
	return r.ApiService.NetworkingProjectNetadpMetricPointListExecute(r)
}

/*
 * NetworkingProjectNetadpMetricPointList List networking/netadp.point
 * List networking/netadp.point
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param netadpId Netadp Id
 * @param metricId metricId
 * @return ApiNetworkingProjectNetadpMetricPointListRequest
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpMetricPointList(ctx _context.Context, projectId string, locationId string, netadpId string, metricId string) ApiNetworkingProjectNetadpMetricPointListRequest {
	return ApiNetworkingProjectNetadpMetricPointListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netadpId: netadpId,
		metricId: metricId,
	}
}

/*
 * Execute executes the request
 * @return []Point
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpMetricPointListExecute(r ApiNetworkingProjectNetadpMetricPointListRequest) ([]Point, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Point
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetadpApiService.NetworkingProjectNetadpMetricPointList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netadp/{netadpId}/metric/{metricId}/point"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netadpId"+"}", _neturl.PathEscape(parameterToString(r.netadpId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metricId"+"}", _neturl.PathEscape(parameterToString(r.metricId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.interval != nil {
		localVarQueryParams.Add("interval", parameterToString(*r.interval, ""))
	}
	if r.timespan != nil {
		localVarQueryParams.Add("timespan", parameterToString(*r.timespan, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetadpServiceGetRequest struct {
	ctx _context.Context
	ApiService *NetworkingProjectNetadpApiService
	projectId string
	locationId string
	netadpId string
	serviceId string
}


func (r ApiNetworkingProjectNetadpServiceGetRequest) Execute() (ResourceService, *_nethttp.Response, error) {
	return r.ApiService.NetworkingProjectNetadpServiceGetExecute(r)
}

/*
 * NetworkingProjectNetadpServiceGet Get networking/netadp.service
 * Get networking/netadp.service
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param netadpId Netadp Id
 * @param serviceId serviceId
 * @return ApiNetworkingProjectNetadpServiceGetRequest
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpServiceGet(ctx _context.Context, projectId string, locationId string, netadpId string, serviceId string) ApiNetworkingProjectNetadpServiceGetRequest {
	return ApiNetworkingProjectNetadpServiceGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netadpId: netadpId,
		serviceId: serviceId,
	}
}

/*
 * Execute executes the request
 * @return ResourceService
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpServiceGetExecute(r ApiNetworkingProjectNetadpServiceGetRequest) (ResourceService, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResourceService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetadpApiService.NetworkingProjectNetadpServiceGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netadp/{netadpId}/service/{serviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netadpId"+"}", _neturl.PathEscape(parameterToString(r.netadpId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serviceId"+"}", _neturl.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetadpServiceListRequest struct {
	ctx _context.Context
	ApiService *NetworkingProjectNetadpApiService
	projectId string
	locationId string
	netadpId string
}


func (r ApiNetworkingProjectNetadpServiceListRequest) Execute() ([]ResourceService, *_nethttp.Response, error) {
	return r.ApiService.NetworkingProjectNetadpServiceListExecute(r)
}

/*
 * NetworkingProjectNetadpServiceList List networking/netadp.service
 * List networking/netadp.service
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param netadpId Netadp Id
 * @return ApiNetworkingProjectNetadpServiceListRequest
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpServiceList(ctx _context.Context, projectId string, locationId string, netadpId string) ApiNetworkingProjectNetadpServiceListRequest {
	return ApiNetworkingProjectNetadpServiceListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netadpId: netadpId,
	}
}

/*
 * Execute executes the request
 * @return []ResourceService
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpServiceListExecute(r ApiNetworkingProjectNetadpServiceListRequest) ([]ResourceService, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ResourceService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetadpApiService.NetworkingProjectNetadpServiceList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netadp/{netadpId}/service"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netadpId"+"}", _neturl.PathEscape(parameterToString(r.netadpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetadpTagCreateRequest struct {
	ctx _context.Context
	ApiService *NetworkingProjectNetadpApiService
	projectId string
	locationId string
	netadpId string
	tag *Tag
}

func (r ApiNetworkingProjectNetadpTagCreateRequest) Tag(tag Tag) ApiNetworkingProjectNetadpTagCreateRequest {
	r.tag = &tag
	return r
}

func (r ApiNetworkingProjectNetadpTagCreateRequest) Execute() (Tag, *_nethttp.Response, error) {
	return r.ApiService.NetworkingProjectNetadpTagCreateExecute(r)
}

/*
 * NetworkingProjectNetadpTagCreate Create networking/netadp.tag
 * Create networking/netadp.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param netadpId Netadp Id
 * @return ApiNetworkingProjectNetadpTagCreateRequest
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpTagCreate(ctx _context.Context, projectId string, locationId string, netadpId string) ApiNetworkingProjectNetadpTagCreateRequest {
	return ApiNetworkingProjectNetadpTagCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netadpId: netadpId,
	}
}

/*
 * Execute executes the request
 * @return Tag
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpTagCreateExecute(r ApiNetworkingProjectNetadpTagCreateRequest) (Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetadpApiService.NetworkingProjectNetadpTagCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netadp/{netadpId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netadpId"+"}", _neturl.PathEscape(parameterToString(r.netadpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.tag == nil {
		return localVarReturnValue, nil, reportError("tag is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tag
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetadpTagDeleteRequest struct {
	ctx _context.Context
	ApiService *NetworkingProjectNetadpApiService
	projectId string
	locationId string
	netadpId string
	tagId string
}


func (r ApiNetworkingProjectNetadpTagDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.NetworkingProjectNetadpTagDeleteExecute(r)
}

/*
 * NetworkingProjectNetadpTagDelete Delete networking/netadp.tag
 * Delete networking/netadp.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param netadpId Netadp Id
 * @param tagId tagId
 * @return ApiNetworkingProjectNetadpTagDeleteRequest
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpTagDelete(ctx _context.Context, projectId string, locationId string, netadpId string, tagId string) ApiNetworkingProjectNetadpTagDeleteRequest {
	return ApiNetworkingProjectNetadpTagDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netadpId: netadpId,
		tagId: tagId,
	}
}

/*
 * Execute executes the request
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpTagDeleteExecute(r ApiNetworkingProjectNetadpTagDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetadpApiService.NetworkingProjectNetadpTagDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netadp/{netadpId}/tag/{tagId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netadpId"+"}", _neturl.PathEscape(parameterToString(r.netadpId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", _neturl.PathEscape(parameterToString(r.tagId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetadpTagGetRequest struct {
	ctx _context.Context
	ApiService *NetworkingProjectNetadpApiService
	projectId string
	locationId string
	netadpId string
	tagId string
}


func (r ApiNetworkingProjectNetadpTagGetRequest) Execute() (Tag, *_nethttp.Response, error) {
	return r.ApiService.NetworkingProjectNetadpTagGetExecute(r)
}

/*
 * NetworkingProjectNetadpTagGet Get networking/netadp.tag
 * Get networking/netadp.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param netadpId Netadp Id
 * @param tagId tagId
 * @return ApiNetworkingProjectNetadpTagGetRequest
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpTagGet(ctx _context.Context, projectId string, locationId string, netadpId string, tagId string) ApiNetworkingProjectNetadpTagGetRequest {
	return ApiNetworkingProjectNetadpTagGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netadpId: netadpId,
		tagId: tagId,
	}
}

/*
 * Execute executes the request
 * @return Tag
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpTagGetExecute(r ApiNetworkingProjectNetadpTagGetRequest) (Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetadpApiService.NetworkingProjectNetadpTagGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netadp/{netadpId}/tag/{tagId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netadpId"+"}", _neturl.PathEscape(parameterToString(r.netadpId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", _neturl.PathEscape(parameterToString(r.tagId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetadpTagListRequest struct {
	ctx _context.Context
	ApiService *NetworkingProjectNetadpApiService
	projectId string
	locationId string
	netadpId string
}


func (r ApiNetworkingProjectNetadpTagListRequest) Execute() ([]Tag, *_nethttp.Response, error) {
	return r.ApiService.NetworkingProjectNetadpTagListExecute(r)
}

/*
 * NetworkingProjectNetadpTagList List networking/netadp.tag
 * List networking/netadp.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param netadpId Netadp Id
 * @return ApiNetworkingProjectNetadpTagListRequest
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpTagList(ctx _context.Context, projectId string, locationId string, netadpId string) ApiNetworkingProjectNetadpTagListRequest {
	return ApiNetworkingProjectNetadpTagListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netadpId: netadpId,
	}
}

/*
 * Execute executes the request
 * @return []Tag
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpTagListExecute(r ApiNetworkingProjectNetadpTagListRequest) ([]Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetadpApiService.NetworkingProjectNetadpTagList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netadp/{netadpId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netadpId"+"}", _neturl.PathEscape(parameterToString(r.netadpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetadpTagPutRequest struct {
	ctx _context.Context
	ApiService *NetworkingProjectNetadpApiService
	projectId string
	locationId string
	netadpId string
	tag *[]Tag
}

func (r ApiNetworkingProjectNetadpTagPutRequest) Tag(tag []Tag) ApiNetworkingProjectNetadpTagPutRequest {
	r.tag = &tag
	return r
}

func (r ApiNetworkingProjectNetadpTagPutRequest) Execute() ([]Tag, *_nethttp.Response, error) {
	return r.ApiService.NetworkingProjectNetadpTagPutExecute(r)
}

/*
 * NetworkingProjectNetadpTagPut Replace networking/netadp.tag
 * Replace networking/netadp.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param netadpId Netadp Id
 * @return ApiNetworkingProjectNetadpTagPutRequest
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpTagPut(ctx _context.Context, projectId string, locationId string, netadpId string) ApiNetworkingProjectNetadpTagPutRequest {
	return ApiNetworkingProjectNetadpTagPutRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netadpId: netadpId,
	}
}

/*
 * Execute executes the request
 * @return []Tag
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpTagPutExecute(r ApiNetworkingProjectNetadpTagPutRequest) ([]Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetadpApiService.NetworkingProjectNetadpTagPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netadp/{netadpId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netadpId"+"}", _neturl.PathEscape(parameterToString(r.netadpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.tag == nil {
		return localVarReturnValue, nil, reportError("tag is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tag
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetadpUpdateRequest struct {
	ctx _context.Context
	ApiService *NetworkingProjectNetadpApiService
	projectId string
	locationId string
	netadpId string
	networkingProjectNetadpUpdate *NetworkingProjectNetadpUpdate
}

func (r ApiNetworkingProjectNetadpUpdateRequest) NetworkingProjectNetadpUpdate(networkingProjectNetadpUpdate NetworkingProjectNetadpUpdate) ApiNetworkingProjectNetadpUpdateRequest {
	r.networkingProjectNetadpUpdate = &networkingProjectNetadpUpdate
	return r
}

func (r ApiNetworkingProjectNetadpUpdateRequest) Execute() (Netadp, *_nethttp.Response, error) {
	return r.ApiService.NetworkingProjectNetadpUpdateExecute(r)
}

/*
 * NetworkingProjectNetadpUpdate Update networking/netadp
 * Returns modified netadp
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param netadpId Netadp Id
 * @return ApiNetworkingProjectNetadpUpdateRequest
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpUpdate(ctx _context.Context, projectId string, locationId string, netadpId string) ApiNetworkingProjectNetadpUpdateRequest {
	return ApiNetworkingProjectNetadpUpdateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netadpId: netadpId,
	}
}

/*
 * Execute executes the request
 * @return Netadp
 */
func (a *NetworkingProjectNetadpApiService) NetworkingProjectNetadpUpdateExecute(r ApiNetworkingProjectNetadpUpdateRequest) (Netadp, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Netadp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetadpApiService.NetworkingProjectNetadpUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netadp/{netadpId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netadpId"+"}", _neturl.PathEscape(parameterToString(r.netadpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.networkingProjectNetadpUpdate == nil {
		return localVarReturnValue, nil, reportError("networkingProjectNetadpUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.networkingProjectNetadpUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
