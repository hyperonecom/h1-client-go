/*
 * HyperOne
 *
 * HyperOne API
 *
 * API version: 0.1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package h1

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"os"
)

// Linger please
var (
	_ _context.Context
)

// ComputeProjectVmApiService ComputeProjectVmApi service
type ComputeProjectVmApiService service

type ApiComputeProjectVmConnectGetRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
	connectId string
}


func (r ApiComputeProjectVmConnectGetRequest) Execute() (Connect, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmConnectGetExecute(r)
}

/*
 * ComputeProjectVmConnectGet Get compute/vm.connect
 * Get compute/vm.connect
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @param connectId connectId
 * @return ApiComputeProjectVmConnectGetRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmConnectGet(ctx _context.Context, projectId string, locationId string, vmId string, connectId string) ApiComputeProjectVmConnectGetRequest {
	return ApiComputeProjectVmConnectGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
		connectId: connectId,
	}
}

/*
 * Execute executes the request
 * @return Connect
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmConnectGetExecute(r ApiComputeProjectVmConnectGetRequest) (Connect, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Connect
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmConnectGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/connect/{connectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectId"+"}", _neturl.PathEscape(parameterToString(r.connectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmConnectListRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
}


func (r ApiComputeProjectVmConnectListRequest) Execute() ([]Connect, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmConnectListExecute(r)
}

/*
 * ComputeProjectVmConnectList List compute/vm.connect
 * List compute/vm.connect
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @return ApiComputeProjectVmConnectListRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmConnectList(ctx _context.Context, projectId string, locationId string, vmId string) ApiComputeProjectVmConnectListRequest {
	return ApiComputeProjectVmConnectListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
	}
}

/*
 * Execute executes the request
 * @return []Connect
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmConnectListExecute(r ApiComputeProjectVmConnectListRequest) ([]Connect, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Connect
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmConnectList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/connect"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmConnectOpenRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
	connectId string
	computeProjectVmConnectOpen *ComputeProjectVmConnectOpen
}

func (r ApiComputeProjectVmConnectOpenRequest) ComputeProjectVmConnectOpen(computeProjectVmConnectOpen ComputeProjectVmConnectOpen) ApiComputeProjectVmConnectOpenRequest {
	r.computeProjectVmConnectOpen = &computeProjectVmConnectOpen
	return r
}

func (r ApiComputeProjectVmConnectOpenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmConnectOpenExecute(r)
}

/*
 * ComputeProjectVmConnectOpen Open compute/vm.connect
 * action open
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @param connectId connectId
 * @return ApiComputeProjectVmConnectOpenRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmConnectOpen(ctx _context.Context, projectId string, locationId string, vmId string, connectId string) ApiComputeProjectVmConnectOpenRequest {
	return ApiComputeProjectVmConnectOpenRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
		connectId: connectId,
	}
}

/*
 * Execute executes the request
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmConnectOpenExecute(r ApiComputeProjectVmConnectOpenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmConnectOpen")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/connect/{connectId}/actions/open"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectId"+"}", _neturl.PathEscape(parameterToString(r.connectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.computeProjectVmConnectOpen == nil {
		return nil, reportError("computeProjectVmConnectOpen is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.computeProjectVmConnectOpen
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiComputeProjectVmCreateRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	computeProjectVmCreate *ComputeProjectVmCreate
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiComputeProjectVmCreateRequest) ComputeProjectVmCreate(computeProjectVmCreate ComputeProjectVmCreate) ApiComputeProjectVmCreateRequest {
	r.computeProjectVmCreate = &computeProjectVmCreate
	return r
}
func (r ApiComputeProjectVmCreateRequest) XIdempotencyKey(xIdempotencyKey string) ApiComputeProjectVmCreateRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
func (r ApiComputeProjectVmCreateRequest) XDryRun(xDryRun string) ApiComputeProjectVmCreateRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiComputeProjectVmCreateRequest) Execute() (Vm, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmCreateExecute(r)
}

/*
 * ComputeProjectVmCreate Create compute/vm
 * Create vm
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @return ApiComputeProjectVmCreateRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmCreate(ctx _context.Context, projectId string, locationId string) ApiComputeProjectVmCreateRequest {
	return ApiComputeProjectVmCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
	}
}

/*
 * Execute executes the request
 * @return Vm
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmCreateExecute(r ApiComputeProjectVmCreateRequest) (Vm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Vm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.computeProjectVmCreate == nil {
		return localVarReturnValue, nil, reportError("computeProjectVmCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	// body params
	localVarPostBody = r.computeProjectVmCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmDeleteRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
}


func (r ApiComputeProjectVmDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmDeleteExecute(r)
}

/*
 * ComputeProjectVmDelete Delete compute/vm
 * Delete vm
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @return ApiComputeProjectVmDeleteRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmDelete(ctx _context.Context, projectId string, locationId string, vmId string) ApiComputeProjectVmDeleteRequest {
	return ApiComputeProjectVmDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
	}
}

/*
 * Execute executes the request
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmDeleteExecute(r ApiComputeProjectVmDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiComputeProjectVmDiskCreateRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
	computeProjectVmDiskCreate *ComputeProjectVmDiskCreate
}

func (r ApiComputeProjectVmDiskCreateRequest) ComputeProjectVmDiskCreate(computeProjectVmDiskCreate ComputeProjectVmDiskCreate) ApiComputeProjectVmDiskCreateRequest {
	r.computeProjectVmDiskCreate = &computeProjectVmDiskCreate
	return r
}

func (r ApiComputeProjectVmDiskCreateRequest) Execute() (Disk, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmDiskCreateExecute(r)
}

/*
 * ComputeProjectVmDiskCreate Create compute/vm.disk
 * Create compute/vm.disk
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @return ApiComputeProjectVmDiskCreateRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmDiskCreate(ctx _context.Context, projectId string, locationId string, vmId string) ApiComputeProjectVmDiskCreateRequest {
	return ApiComputeProjectVmDiskCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
	}
}

/*
 * Execute executes the request
 * @return Disk
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmDiskCreateExecute(r ApiComputeProjectVmDiskCreateRequest) (Disk, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Disk
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmDiskCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/disk"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.computeProjectVmDiskCreate == nil {
		return localVarReturnValue, nil, reportError("computeProjectVmDiskCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.computeProjectVmDiskCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmDiskListRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
}


func (r ApiComputeProjectVmDiskListRequest) Execute() ([]Disk, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmDiskListExecute(r)
}

/*
 * ComputeProjectVmDiskList List compute/vm.disk
 * List compute/vm.disk
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @return ApiComputeProjectVmDiskListRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmDiskList(ctx _context.Context, projectId string, locationId string, vmId string) ApiComputeProjectVmDiskListRequest {
	return ApiComputeProjectVmDiskListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
	}
}

/*
 * Execute executes the request
 * @return []Disk
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmDiskListExecute(r ApiComputeProjectVmDiskListRequest) ([]Disk, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Disk
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmDiskList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/disk"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmEventGetRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
	eventId string
}


func (r ApiComputeProjectVmEventGetRequest) Execute() (Event, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmEventGetExecute(r)
}

/*
 * ComputeProjectVmEventGet Get compute/vm.event
 * Get compute/vm.event
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @param eventId eventId
 * @return ApiComputeProjectVmEventGetRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmEventGet(ctx _context.Context, projectId string, locationId string, vmId string, eventId string) ApiComputeProjectVmEventGetRequest {
	return ApiComputeProjectVmEventGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
		eventId: eventId,
	}
}

/*
 * Execute executes the request
 * @return Event
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmEventGetExecute(r ApiComputeProjectVmEventGetRequest) (Event, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmEventGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/event/{eventId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmEventListRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
	limit *float32
	skip *float32
}

func (r ApiComputeProjectVmEventListRequest) Limit(limit float32) ApiComputeProjectVmEventListRequest {
	r.limit = &limit
	return r
}
func (r ApiComputeProjectVmEventListRequest) Skip(skip float32) ApiComputeProjectVmEventListRequest {
	r.skip = &skip
	return r
}

func (r ApiComputeProjectVmEventListRequest) Execute() ([]Event, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmEventListExecute(r)
}

/*
 * ComputeProjectVmEventList List compute/vm.event
 * List compute/vm.event
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @return ApiComputeProjectVmEventListRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmEventList(ctx _context.Context, projectId string, locationId string, vmId string) ApiComputeProjectVmEventListRequest {
	return ApiComputeProjectVmEventListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
	}
}

/*
 * Execute executes the request
 * @return []Event
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmEventListExecute(r ApiComputeProjectVmEventListRequest) ([]Event, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmEventList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/event"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("$limit", parameterToString(*r.limit, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmFlavourRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
	computeProjectVmFlavour *ComputeProjectVmFlavour
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiComputeProjectVmFlavourRequest) ComputeProjectVmFlavour(computeProjectVmFlavour ComputeProjectVmFlavour) ApiComputeProjectVmFlavourRequest {
	r.computeProjectVmFlavour = &computeProjectVmFlavour
	return r
}
func (r ApiComputeProjectVmFlavourRequest) XIdempotencyKey(xIdempotencyKey string) ApiComputeProjectVmFlavourRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
func (r ApiComputeProjectVmFlavourRequest) XDryRun(xDryRun string) ApiComputeProjectVmFlavourRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiComputeProjectVmFlavourRequest) Execute() (Vm, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmFlavourExecute(r)
}

/*
 * ComputeProjectVmFlavour Flavour compute/vm
 * action flavour
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @return ApiComputeProjectVmFlavourRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmFlavour(ctx _context.Context, projectId string, locationId string, vmId string) ApiComputeProjectVmFlavourRequest {
	return ApiComputeProjectVmFlavourRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
	}
}

/*
 * Execute executes the request
 * @return Vm
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmFlavourExecute(r ApiComputeProjectVmFlavourRequest) (Vm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Vm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmFlavour")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/actions/flavour"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.computeProjectVmFlavour == nil {
		return localVarReturnValue, nil, reportError("computeProjectVmFlavour is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	// body params
	localVarPostBody = r.computeProjectVmFlavour
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmGetRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
}


func (r ApiComputeProjectVmGetRequest) Execute() (Vm, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmGetExecute(r)
}

/*
 * ComputeProjectVmGet Get compute/vm
 * Returns a single vm
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @return ApiComputeProjectVmGetRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmGet(ctx _context.Context, projectId string, locationId string, vmId string) ApiComputeProjectVmGetRequest {
	return ApiComputeProjectVmGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
	}
}

/*
 * Execute executes the request
 * @return Vm
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmGetExecute(r ApiComputeProjectVmGetRequest) (Vm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Vm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmIsoCreateRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
	computeProjectVmIsoCreate *ComputeProjectVmIsoCreate
}

func (r ApiComputeProjectVmIsoCreateRequest) ComputeProjectVmIsoCreate(computeProjectVmIsoCreate ComputeProjectVmIsoCreate) ApiComputeProjectVmIsoCreateRequest {
	r.computeProjectVmIsoCreate = &computeProjectVmIsoCreate
	return r
}

func (r ApiComputeProjectVmIsoCreateRequest) Execute() (Iso, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmIsoCreateExecute(r)
}

/*
 * ComputeProjectVmIsoCreate Create compute/vm.iso
 * Create compute/vm.iso
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @return ApiComputeProjectVmIsoCreateRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmIsoCreate(ctx _context.Context, projectId string, locationId string, vmId string) ApiComputeProjectVmIsoCreateRequest {
	return ApiComputeProjectVmIsoCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
	}
}

/*
 * Execute executes the request
 * @return Iso
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmIsoCreateExecute(r ApiComputeProjectVmIsoCreateRequest) (Iso, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Iso
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmIsoCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/iso"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.computeProjectVmIsoCreate == nil {
		return localVarReturnValue, nil, reportError("computeProjectVmIsoCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.computeProjectVmIsoCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmIsoListRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
}


func (r ApiComputeProjectVmIsoListRequest) Execute() ([]Iso, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmIsoListExecute(r)
}

/*
 * ComputeProjectVmIsoList List compute/vm.iso
 * List compute/vm.iso
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @return ApiComputeProjectVmIsoListRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmIsoList(ctx _context.Context, projectId string, locationId string, vmId string) ApiComputeProjectVmIsoListRequest {
	return ApiComputeProjectVmIsoListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
	}
}

/*
 * Execute executes the request
 * @return []Iso
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmIsoListExecute(r ApiComputeProjectVmIsoListRequest) ([]Iso, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Iso
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmIsoList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/iso"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmListRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	name *string
	tagValue *string
	tagKey *string
}

func (r ApiComputeProjectVmListRequest) Name(name string) ApiComputeProjectVmListRequest {
	r.name = &name
	return r
}
func (r ApiComputeProjectVmListRequest) TagValue(tagValue string) ApiComputeProjectVmListRequest {
	r.tagValue = &tagValue
	return r
}
func (r ApiComputeProjectVmListRequest) TagKey(tagKey string) ApiComputeProjectVmListRequest {
	r.tagKey = &tagKey
	return r
}

func (r ApiComputeProjectVmListRequest) Execute() ([]Vm, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmListExecute(r)
}

/*
 * ComputeProjectVmList List compute/vm
 * List vm
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @return ApiComputeProjectVmListRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmList(ctx _context.Context, projectId string, locationId string) ApiComputeProjectVmListRequest {
	return ApiComputeProjectVmListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
	}
}

/*
 * Execute executes the request
 * @return []Vm
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmListExecute(r ApiComputeProjectVmListRequest) ([]Vm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Vm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.tagValue != nil {
		localVarQueryParams.Add("tag.value", parameterToString(*r.tagValue, ""))
	}
	if r.tagKey != nil {
		localVarQueryParams.Add("tag.key", parameterToString(*r.tagKey, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmMetricGetRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
	metricId string
}


func (r ApiComputeProjectVmMetricGetRequest) Execute() (Metric, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmMetricGetExecute(r)
}

/*
 * ComputeProjectVmMetricGet Get compute/vm.metric
 * Get compute/vm.metric
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @param metricId metricId
 * @return ApiComputeProjectVmMetricGetRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmMetricGet(ctx _context.Context, projectId string, locationId string, vmId string, metricId string) ApiComputeProjectVmMetricGetRequest {
	return ApiComputeProjectVmMetricGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
		metricId: metricId,
	}
}

/*
 * Execute executes the request
 * @return Metric
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmMetricGetExecute(r ApiComputeProjectVmMetricGetRequest) (Metric, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Metric
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmMetricGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/metric/{metricId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metricId"+"}", _neturl.PathEscape(parameterToString(r.metricId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmMetricListRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
}


func (r ApiComputeProjectVmMetricListRequest) Execute() ([]Metric, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmMetricListExecute(r)
}

/*
 * ComputeProjectVmMetricList List compute/vm.metric
 * List compute/vm.metric
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @return ApiComputeProjectVmMetricListRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmMetricList(ctx _context.Context, projectId string, locationId string, vmId string) ApiComputeProjectVmMetricListRequest {
	return ApiComputeProjectVmMetricListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
	}
}

/*
 * Execute executes the request
 * @return []Metric
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmMetricListExecute(r ApiComputeProjectVmMetricListRequest) ([]Metric, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Metric
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmMetricList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/metric"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmMetricPointListRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
	metricId string
	interval *string
	timespan *string
}

func (r ApiComputeProjectVmMetricPointListRequest) Interval(interval string) ApiComputeProjectVmMetricPointListRequest {
	r.interval = &interval
	return r
}
func (r ApiComputeProjectVmMetricPointListRequest) Timespan(timespan string) ApiComputeProjectVmMetricPointListRequest {
	r.timespan = &timespan
	return r
}

func (r ApiComputeProjectVmMetricPointListRequest) Execute() ([]Point, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmMetricPointListExecute(r)
}

/*
 * ComputeProjectVmMetricPointList List compute/vm.point
 * List compute/vm.point
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @param metricId metricId
 * @return ApiComputeProjectVmMetricPointListRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmMetricPointList(ctx _context.Context, projectId string, locationId string, vmId string, metricId string) ApiComputeProjectVmMetricPointListRequest {
	return ApiComputeProjectVmMetricPointListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
		metricId: metricId,
	}
}

/*
 * Execute executes the request
 * @return []Point
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmMetricPointListExecute(r ApiComputeProjectVmMetricPointListRequest) ([]Point, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Point
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmMetricPointList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/metric/{metricId}/point"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metricId"+"}", _neturl.PathEscape(parameterToString(r.metricId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.interval != nil {
		localVarQueryParams.Add("interval", parameterToString(*r.interval, ""))
	}
	if r.timespan != nil {
		localVarQueryParams.Add("timespan", parameterToString(*r.timespan, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmPasswordResetRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
	computeProjectVmPasswordReset *ComputeProjectVmPasswordReset
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiComputeProjectVmPasswordResetRequest) ComputeProjectVmPasswordReset(computeProjectVmPasswordReset ComputeProjectVmPasswordReset) ApiComputeProjectVmPasswordResetRequest {
	r.computeProjectVmPasswordReset = &computeProjectVmPasswordReset
	return r
}
func (r ApiComputeProjectVmPasswordResetRequest) XIdempotencyKey(xIdempotencyKey string) ApiComputeProjectVmPasswordResetRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
func (r ApiComputeProjectVmPasswordResetRequest) XDryRun(xDryRun string) ApiComputeProjectVmPasswordResetRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiComputeProjectVmPasswordResetRequest) Execute() (Vm, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmPasswordResetExecute(r)
}

/*
 * ComputeProjectVmPasswordReset Password reset compute/vm
 * action password_reset
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @return ApiComputeProjectVmPasswordResetRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmPasswordReset(ctx _context.Context, projectId string, locationId string, vmId string) ApiComputeProjectVmPasswordResetRequest {
	return ApiComputeProjectVmPasswordResetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
	}
}

/*
 * Execute executes the request
 * @return Vm
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmPasswordResetExecute(r ApiComputeProjectVmPasswordResetRequest) (Vm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Vm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmPasswordReset")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/actions/password_reset"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.computeProjectVmPasswordReset == nil {
		return localVarReturnValue, nil, reportError("computeProjectVmPasswordReset is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	// body params
	localVarPostBody = r.computeProjectVmPasswordReset
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmRestartRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiComputeProjectVmRestartRequest) XIdempotencyKey(xIdempotencyKey string) ApiComputeProjectVmRestartRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
func (r ApiComputeProjectVmRestartRequest) XDryRun(xDryRun string) ApiComputeProjectVmRestartRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiComputeProjectVmRestartRequest) Execute() (Vm, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmRestartExecute(r)
}

/*
 * ComputeProjectVmRestart Restart compute/vm
 * action restart
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @return ApiComputeProjectVmRestartRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmRestart(ctx _context.Context, projectId string, locationId string, vmId string) ApiComputeProjectVmRestartRequest {
	return ApiComputeProjectVmRestartRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
	}
}

/*
 * Execute executes the request
 * @return Vm
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmRestartExecute(r ApiComputeProjectVmRestartRequest) (Vm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Vm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmRestart")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/actions/restart"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmSerialportRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
	computeProjectVmSerialport *ComputeProjectVmSerialport
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiComputeProjectVmSerialportRequest) ComputeProjectVmSerialport(computeProjectVmSerialport ComputeProjectVmSerialport) ApiComputeProjectVmSerialportRequest {
	r.computeProjectVmSerialport = &computeProjectVmSerialport
	return r
}
func (r ApiComputeProjectVmSerialportRequest) XIdempotencyKey(xIdempotencyKey string) ApiComputeProjectVmSerialportRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
func (r ApiComputeProjectVmSerialportRequest) XDryRun(xDryRun string) ApiComputeProjectVmSerialportRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiComputeProjectVmSerialportRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmSerialportExecute(r)
}

/*
 * ComputeProjectVmSerialport Serialport compute/vm
 * action serialport
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @return ApiComputeProjectVmSerialportRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmSerialport(ctx _context.Context, projectId string, locationId string, vmId string) ApiComputeProjectVmSerialportRequest {
	return ApiComputeProjectVmSerialportRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
	}
}

/*
 * Execute executes the request
 * @return *os.File
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmSerialportExecute(r ApiComputeProjectVmSerialportRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmSerialport")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/actions/serialport"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.computeProjectVmSerialport == nil {
		return localVarReturnValue, nil, reportError("computeProjectVmSerialport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	// body params
	localVarPostBody = r.computeProjectVmSerialport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmServiceGetRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
	serviceId string
}


func (r ApiComputeProjectVmServiceGetRequest) Execute() (ResourceService, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmServiceGetExecute(r)
}

/*
 * ComputeProjectVmServiceGet Get compute/vm.service
 * Get compute/vm.service
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @param serviceId serviceId
 * @return ApiComputeProjectVmServiceGetRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmServiceGet(ctx _context.Context, projectId string, locationId string, vmId string, serviceId string) ApiComputeProjectVmServiceGetRequest {
	return ApiComputeProjectVmServiceGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
		serviceId: serviceId,
	}
}

/*
 * Execute executes the request
 * @return ResourceService
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmServiceGetExecute(r ApiComputeProjectVmServiceGetRequest) (ResourceService, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResourceService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmServiceGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/service/{serviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serviceId"+"}", _neturl.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmServiceListRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
}


func (r ApiComputeProjectVmServiceListRequest) Execute() ([]ResourceService, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmServiceListExecute(r)
}

/*
 * ComputeProjectVmServiceList List compute/vm.service
 * List compute/vm.service
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @return ApiComputeProjectVmServiceListRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmServiceList(ctx _context.Context, projectId string, locationId string, vmId string) ApiComputeProjectVmServiceListRequest {
	return ApiComputeProjectVmServiceListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
	}
}

/*
 * Execute executes the request
 * @return []ResourceService
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmServiceListExecute(r ApiComputeProjectVmServiceListRequest) ([]ResourceService, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ResourceService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmServiceList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/service"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmStartRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiComputeProjectVmStartRequest) XIdempotencyKey(xIdempotencyKey string) ApiComputeProjectVmStartRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
func (r ApiComputeProjectVmStartRequest) XDryRun(xDryRun string) ApiComputeProjectVmStartRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiComputeProjectVmStartRequest) Execute() (Vm, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmStartExecute(r)
}

/*
 * ComputeProjectVmStart Start compute/vm
 * action start
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @return ApiComputeProjectVmStartRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmStart(ctx _context.Context, projectId string, locationId string, vmId string) ApiComputeProjectVmStartRequest {
	return ApiComputeProjectVmStartRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
	}
}

/*
 * Execute executes the request
 * @return Vm
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmStartExecute(r ApiComputeProjectVmStartRequest) (Vm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Vm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmStart")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/actions/start"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmStopRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiComputeProjectVmStopRequest) XIdempotencyKey(xIdempotencyKey string) ApiComputeProjectVmStopRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
func (r ApiComputeProjectVmStopRequest) XDryRun(xDryRun string) ApiComputeProjectVmStopRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiComputeProjectVmStopRequest) Execute() (Vm, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmStopExecute(r)
}

/*
 * ComputeProjectVmStop Stop compute/vm
 * action stop
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @return ApiComputeProjectVmStopRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmStop(ctx _context.Context, projectId string, locationId string, vmId string) ApiComputeProjectVmStopRequest {
	return ApiComputeProjectVmStopRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
	}
}

/*
 * Execute executes the request
 * @return Vm
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmStopExecute(r ApiComputeProjectVmStopRequest) (Vm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Vm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmStop")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/actions/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmTagCreateRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
	tag *Tag
}

func (r ApiComputeProjectVmTagCreateRequest) Tag(tag Tag) ApiComputeProjectVmTagCreateRequest {
	r.tag = &tag
	return r
}

func (r ApiComputeProjectVmTagCreateRequest) Execute() (Tag, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmTagCreateExecute(r)
}

/*
 * ComputeProjectVmTagCreate Create compute/vm.tag
 * Create compute/vm.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @return ApiComputeProjectVmTagCreateRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmTagCreate(ctx _context.Context, projectId string, locationId string, vmId string) ApiComputeProjectVmTagCreateRequest {
	return ApiComputeProjectVmTagCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
	}
}

/*
 * Execute executes the request
 * @return Tag
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmTagCreateExecute(r ApiComputeProjectVmTagCreateRequest) (Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmTagCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.tag == nil {
		return localVarReturnValue, nil, reportError("tag is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tag
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmTagDeleteRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
	tagId string
}


func (r ApiComputeProjectVmTagDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmTagDeleteExecute(r)
}

/*
 * ComputeProjectVmTagDelete Delete compute/vm.tag
 * Delete compute/vm.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @param tagId tagId
 * @return ApiComputeProjectVmTagDeleteRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmTagDelete(ctx _context.Context, projectId string, locationId string, vmId string, tagId string) ApiComputeProjectVmTagDeleteRequest {
	return ApiComputeProjectVmTagDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
		tagId: tagId,
	}
}

/*
 * Execute executes the request
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmTagDeleteExecute(r ApiComputeProjectVmTagDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmTagDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/tag/{tagId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", _neturl.PathEscape(parameterToString(r.tagId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiComputeProjectVmTagGetRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
	tagId string
}


func (r ApiComputeProjectVmTagGetRequest) Execute() (Tag, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmTagGetExecute(r)
}

/*
 * ComputeProjectVmTagGet Get compute/vm.tag
 * Get compute/vm.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @param tagId tagId
 * @return ApiComputeProjectVmTagGetRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmTagGet(ctx _context.Context, projectId string, locationId string, vmId string, tagId string) ApiComputeProjectVmTagGetRequest {
	return ApiComputeProjectVmTagGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
		tagId: tagId,
	}
}

/*
 * Execute executes the request
 * @return Tag
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmTagGetExecute(r ApiComputeProjectVmTagGetRequest) (Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmTagGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/tag/{tagId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", _neturl.PathEscape(parameterToString(r.tagId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmTagListRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
}


func (r ApiComputeProjectVmTagListRequest) Execute() ([]Tag, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmTagListExecute(r)
}

/*
 * ComputeProjectVmTagList List compute/vm.tag
 * List compute/vm.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @return ApiComputeProjectVmTagListRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmTagList(ctx _context.Context, projectId string, locationId string, vmId string) ApiComputeProjectVmTagListRequest {
	return ApiComputeProjectVmTagListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
	}
}

/*
 * Execute executes the request
 * @return []Tag
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmTagListExecute(r ApiComputeProjectVmTagListRequest) ([]Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmTagList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmTagPutRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
	tag *[]Tag
}

func (r ApiComputeProjectVmTagPutRequest) Tag(tag []Tag) ApiComputeProjectVmTagPutRequest {
	r.tag = &tag
	return r
}

func (r ApiComputeProjectVmTagPutRequest) Execute() ([]Tag, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmTagPutExecute(r)
}

/*
 * ComputeProjectVmTagPut Replace compute/vm.tag
 * Replace compute/vm.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @return ApiComputeProjectVmTagPutRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmTagPut(ctx _context.Context, projectId string, locationId string, vmId string) ApiComputeProjectVmTagPutRequest {
	return ApiComputeProjectVmTagPutRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
	}
}

/*
 * Execute executes the request
 * @return []Tag
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmTagPutExecute(r ApiComputeProjectVmTagPutRequest) ([]Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmTagPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.tag == nil {
		return localVarReturnValue, nil, reportError("tag is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tag
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmTurnoffRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiComputeProjectVmTurnoffRequest) XIdempotencyKey(xIdempotencyKey string) ApiComputeProjectVmTurnoffRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
func (r ApiComputeProjectVmTurnoffRequest) XDryRun(xDryRun string) ApiComputeProjectVmTurnoffRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiComputeProjectVmTurnoffRequest) Execute() (Vm, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmTurnoffExecute(r)
}

/*
 * ComputeProjectVmTurnoff Turnoff compute/vm
 * action turnoff
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @return ApiComputeProjectVmTurnoffRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmTurnoff(ctx _context.Context, projectId string, locationId string, vmId string) ApiComputeProjectVmTurnoffRequest {
	return ApiComputeProjectVmTurnoffRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
	}
}

/*
 * Execute executes the request
 * @return Vm
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmTurnoffExecute(r ApiComputeProjectVmTurnoffRequest) (Vm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Vm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmTurnoff")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}/actions/turnoff"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeProjectVmUpdateRequest struct {
	ctx _context.Context
	ApiService *ComputeProjectVmApiService
	projectId string
	locationId string
	vmId string
	computeProjectVmUpdate *ComputeProjectVmUpdate
}

func (r ApiComputeProjectVmUpdateRequest) ComputeProjectVmUpdate(computeProjectVmUpdate ComputeProjectVmUpdate) ApiComputeProjectVmUpdateRequest {
	r.computeProjectVmUpdate = &computeProjectVmUpdate
	return r
}

func (r ApiComputeProjectVmUpdateRequest) Execute() (Vm, *_nethttp.Response, error) {
	return r.ApiService.ComputeProjectVmUpdateExecute(r)
}

/*
 * ComputeProjectVmUpdate Update compute/vm
 * Returns modified vm
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param vmId Vm Id
 * @return ApiComputeProjectVmUpdateRequest
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmUpdate(ctx _context.Context, projectId string, locationId string, vmId string) ApiComputeProjectVmUpdateRequest {
	return ApiComputeProjectVmUpdateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		vmId: vmId,
	}
}

/*
 * Execute executes the request
 * @return Vm
 */
func (a *ComputeProjectVmApiService) ComputeProjectVmUpdateExecute(r ApiComputeProjectVmUpdateRequest) (Vm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Vm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeProjectVmApiService.ComputeProjectVmUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/compute/{locationId}/project/{projectId}/vm/{vmId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vmId"+"}", _neturl.PathEscape(parameterToString(r.vmId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.computeProjectVmUpdate == nil {
		return localVarReturnValue, nil, reportError("computeProjectVmUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.computeProjectVmUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
