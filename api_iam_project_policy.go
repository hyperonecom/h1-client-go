/*
 * HyperOne
 *
 * HyperOne API
 *
 * API version: 0.1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package h1

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// IamProjectPolicyApiService IamProjectPolicyApi service
type IamProjectPolicyApiService service

type ApiIamProjectPolicyActorCreateRequest struct {
	ctx _context.Context
	ApiService *IamProjectPolicyApiService
	projectId string
	policyId string
	iamActor *IamActor
}

func (r ApiIamProjectPolicyActorCreateRequest) IamActor(iamActor IamActor) ApiIamProjectPolicyActorCreateRequest {
	r.iamActor = &iamActor
	return r
}

func (r ApiIamProjectPolicyActorCreateRequest) Execute() (IamActor, *_nethttp.Response, error) {
	return r.ApiService.IamProjectPolicyActorCreateExecute(r)
}

/*
 * IamProjectPolicyActorCreate Create iam/policy.actor
 * Create iam/policy.actor
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param policyId Policy Id
 * @return ApiIamProjectPolicyActorCreateRequest
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyActorCreate(ctx _context.Context, projectId string, policyId string) ApiIamProjectPolicyActorCreateRequest {
	return ApiIamProjectPolicyActorCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		policyId: policyId,
	}
}

/*
 * Execute executes the request
 * @return IamActor
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyActorCreateExecute(r ApiIamProjectPolicyActorCreateRequest) (IamActor, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IamActor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamProjectPolicyApiService.IamProjectPolicyActorCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/project/{projectId}/policy/{policyId}/actor"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.PathEscape(parameterToString(r.policyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.iamActor == nil {
		return localVarReturnValue, nil, reportError("iamActor is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iamActor
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamProjectPolicyActorDeleteRequest struct {
	ctx _context.Context
	ApiService *IamProjectPolicyApiService
	projectId string
	policyId string
	actorId string
}


func (r ApiIamProjectPolicyActorDeleteRequest) Execute() (IamActor, *_nethttp.Response, error) {
	return r.ApiService.IamProjectPolicyActorDeleteExecute(r)
}

/*
 * IamProjectPolicyActorDelete Delete iam/policy.actor
 * Delete iam/policy.actor
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param policyId Policy Id
 * @param actorId actorId
 * @return ApiIamProjectPolicyActorDeleteRequest
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyActorDelete(ctx _context.Context, projectId string, policyId string, actorId string) ApiIamProjectPolicyActorDeleteRequest {
	return ApiIamProjectPolicyActorDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		policyId: policyId,
		actorId: actorId,
	}
}

/*
 * Execute executes the request
 * @return IamActor
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyActorDeleteExecute(r ApiIamProjectPolicyActorDeleteRequest) (IamActor, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IamActor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamProjectPolicyApiService.IamProjectPolicyActorDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/project/{projectId}/policy/{policyId}/actor/{actorId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.PathEscape(parameterToString(r.policyId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"actorId"+"}", _neturl.PathEscape(parameterToString(r.actorId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamProjectPolicyActorGetRequest struct {
	ctx _context.Context
	ApiService *IamProjectPolicyApiService
	projectId string
	policyId string
	actorId string
}


func (r ApiIamProjectPolicyActorGetRequest) Execute() (IamActor, *_nethttp.Response, error) {
	return r.ApiService.IamProjectPolicyActorGetExecute(r)
}

/*
 * IamProjectPolicyActorGet Get iam/policy.actor
 * Get iam/policy.actor
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param policyId Policy Id
 * @param actorId actorId
 * @return ApiIamProjectPolicyActorGetRequest
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyActorGet(ctx _context.Context, projectId string, policyId string, actorId string) ApiIamProjectPolicyActorGetRequest {
	return ApiIamProjectPolicyActorGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		policyId: policyId,
		actorId: actorId,
	}
}

/*
 * Execute executes the request
 * @return IamActor
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyActorGetExecute(r ApiIamProjectPolicyActorGetRequest) (IamActor, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IamActor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamProjectPolicyApiService.IamProjectPolicyActorGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/project/{projectId}/policy/{policyId}/actor/{actorId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.PathEscape(parameterToString(r.policyId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"actorId"+"}", _neturl.PathEscape(parameterToString(r.actorId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamProjectPolicyActorListRequest struct {
	ctx _context.Context
	ApiService *IamProjectPolicyApiService
	projectId string
	policyId string
}


func (r ApiIamProjectPolicyActorListRequest) Execute() ([]IamActor, *_nethttp.Response, error) {
	return r.ApiService.IamProjectPolicyActorListExecute(r)
}

/*
 * IamProjectPolicyActorList List iam/policy.actor
 * List iam/policy.actor
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param policyId Policy Id
 * @return ApiIamProjectPolicyActorListRequest
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyActorList(ctx _context.Context, projectId string, policyId string) ApiIamProjectPolicyActorListRequest {
	return ApiIamProjectPolicyActorListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		policyId: policyId,
	}
}

/*
 * Execute executes the request
 * @return []IamActor
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyActorListExecute(r ApiIamProjectPolicyActorListRequest) ([]IamActor, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []IamActor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamProjectPolicyApiService.IamProjectPolicyActorList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/project/{projectId}/policy/{policyId}/actor"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.PathEscape(parameterToString(r.policyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamProjectPolicyCreateRequest struct {
	ctx _context.Context
	ApiService *IamProjectPolicyApiService
	projectId string
	iamProjectPolicyCreate *IamProjectPolicyCreate
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiIamProjectPolicyCreateRequest) IamProjectPolicyCreate(iamProjectPolicyCreate IamProjectPolicyCreate) ApiIamProjectPolicyCreateRequest {
	r.iamProjectPolicyCreate = &iamProjectPolicyCreate
	return r
}
func (r ApiIamProjectPolicyCreateRequest) XIdempotencyKey(xIdempotencyKey string) ApiIamProjectPolicyCreateRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
func (r ApiIamProjectPolicyCreateRequest) XDryRun(xDryRun string) ApiIamProjectPolicyCreateRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiIamProjectPolicyCreateRequest) Execute() (Policy, *_nethttp.Response, error) {
	return r.ApiService.IamProjectPolicyCreateExecute(r)
}

/*
 * IamProjectPolicyCreate Create iam/policy
 * Create policy
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @return ApiIamProjectPolicyCreateRequest
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyCreate(ctx _context.Context, projectId string) ApiIamProjectPolicyCreateRequest {
	return ApiIamProjectPolicyCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

/*
 * Execute executes the request
 * @return Policy
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyCreateExecute(r ApiIamProjectPolicyCreateRequest) (Policy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Policy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamProjectPolicyApiService.IamProjectPolicyCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/project/{projectId}/policy"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.iamProjectPolicyCreate == nil {
		return localVarReturnValue, nil, reportError("iamProjectPolicyCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	// body params
	localVarPostBody = r.iamProjectPolicyCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamProjectPolicyDeleteRequest struct {
	ctx _context.Context
	ApiService *IamProjectPolicyApiService
	projectId string
	policyId string
}


func (r ApiIamProjectPolicyDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IamProjectPolicyDeleteExecute(r)
}

/*
 * IamProjectPolicyDelete Delete iam/policy
 * Delete policy
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param policyId Policy Id
 * @return ApiIamProjectPolicyDeleteRequest
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyDelete(ctx _context.Context, projectId string, policyId string) ApiIamProjectPolicyDeleteRequest {
	return ApiIamProjectPolicyDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		policyId: policyId,
	}
}

/*
 * Execute executes the request
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyDeleteExecute(r ApiIamProjectPolicyDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamProjectPolicyApiService.IamProjectPolicyDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/project/{projectId}/policy/{policyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.PathEscape(parameterToString(r.policyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIamProjectPolicyEventGetRequest struct {
	ctx _context.Context
	ApiService *IamProjectPolicyApiService
	projectId string
	policyId string
	eventId string
}


func (r ApiIamProjectPolicyEventGetRequest) Execute() (Event, *_nethttp.Response, error) {
	return r.ApiService.IamProjectPolicyEventGetExecute(r)
}

/*
 * IamProjectPolicyEventGet Get iam/policy.event
 * Get iam/policy.event
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param policyId Policy Id
 * @param eventId eventId
 * @return ApiIamProjectPolicyEventGetRequest
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyEventGet(ctx _context.Context, projectId string, policyId string, eventId string) ApiIamProjectPolicyEventGetRequest {
	return ApiIamProjectPolicyEventGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		policyId: policyId,
		eventId: eventId,
	}
}

/*
 * Execute executes the request
 * @return Event
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyEventGetExecute(r ApiIamProjectPolicyEventGetRequest) (Event, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamProjectPolicyApiService.IamProjectPolicyEventGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/project/{projectId}/policy/{policyId}/event/{eventId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.PathEscape(parameterToString(r.policyId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamProjectPolicyEventListRequest struct {
	ctx _context.Context
	ApiService *IamProjectPolicyApiService
	projectId string
	policyId string
	limit *float32
	skip *float32
}

func (r ApiIamProjectPolicyEventListRequest) Limit(limit float32) ApiIamProjectPolicyEventListRequest {
	r.limit = &limit
	return r
}
func (r ApiIamProjectPolicyEventListRequest) Skip(skip float32) ApiIamProjectPolicyEventListRequest {
	r.skip = &skip
	return r
}

func (r ApiIamProjectPolicyEventListRequest) Execute() ([]Event, *_nethttp.Response, error) {
	return r.ApiService.IamProjectPolicyEventListExecute(r)
}

/*
 * IamProjectPolicyEventList List iam/policy.event
 * List iam/policy.event
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param policyId Policy Id
 * @return ApiIamProjectPolicyEventListRequest
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyEventList(ctx _context.Context, projectId string, policyId string) ApiIamProjectPolicyEventListRequest {
	return ApiIamProjectPolicyEventListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		policyId: policyId,
	}
}

/*
 * Execute executes the request
 * @return []Event
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyEventListExecute(r ApiIamProjectPolicyEventListRequest) ([]Event, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamProjectPolicyApiService.IamProjectPolicyEventList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/project/{projectId}/policy/{policyId}/event"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.PathEscape(parameterToString(r.policyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("$limit", parameterToString(*r.limit, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamProjectPolicyGetRequest struct {
	ctx _context.Context
	ApiService *IamProjectPolicyApiService
	projectId string
	policyId string
}


func (r ApiIamProjectPolicyGetRequest) Execute() (Policy, *_nethttp.Response, error) {
	return r.ApiService.IamProjectPolicyGetExecute(r)
}

/*
 * IamProjectPolicyGet Get iam/policy
 * Returns a single policy
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param policyId Policy Id
 * @return ApiIamProjectPolicyGetRequest
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyGet(ctx _context.Context, projectId string, policyId string) ApiIamProjectPolicyGetRequest {
	return ApiIamProjectPolicyGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		policyId: policyId,
	}
}

/*
 * Execute executes the request
 * @return Policy
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyGetExecute(r ApiIamProjectPolicyGetRequest) (Policy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Policy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamProjectPolicyApiService.IamProjectPolicyGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/project/{projectId}/policy/{policyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.PathEscape(parameterToString(r.policyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamProjectPolicyListRequest struct {
	ctx _context.Context
	ApiService *IamProjectPolicyApiService
	projectId string
	name *string
	resource *string
	tagValue *string
	tagKey *string
}

func (r ApiIamProjectPolicyListRequest) Name(name string) ApiIamProjectPolicyListRequest {
	r.name = &name
	return r
}
func (r ApiIamProjectPolicyListRequest) Resource(resource string) ApiIamProjectPolicyListRequest {
	r.resource = &resource
	return r
}
func (r ApiIamProjectPolicyListRequest) TagValue(tagValue string) ApiIamProjectPolicyListRequest {
	r.tagValue = &tagValue
	return r
}
func (r ApiIamProjectPolicyListRequest) TagKey(tagKey string) ApiIamProjectPolicyListRequest {
	r.tagKey = &tagKey
	return r
}

func (r ApiIamProjectPolicyListRequest) Execute() ([]Policy, *_nethttp.Response, error) {
	return r.ApiService.IamProjectPolicyListExecute(r)
}

/*
 * IamProjectPolicyList List iam/policy
 * List policy
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @return ApiIamProjectPolicyListRequest
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyList(ctx _context.Context, projectId string) ApiIamProjectPolicyListRequest {
	return ApiIamProjectPolicyListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

/*
 * Execute executes the request
 * @return []Policy
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyListExecute(r ApiIamProjectPolicyListRequest) ([]Policy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Policy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamProjectPolicyApiService.IamProjectPolicyList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/project/{projectId}/policy"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.resource != nil {
		localVarQueryParams.Add("resource", parameterToString(*r.resource, ""))
	}
	if r.tagValue != nil {
		localVarQueryParams.Add("tag.value", parameterToString(*r.tagValue, ""))
	}
	if r.tagKey != nil {
		localVarQueryParams.Add("tag.key", parameterToString(*r.tagKey, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamProjectPolicyServiceGetRequest struct {
	ctx _context.Context
	ApiService *IamProjectPolicyApiService
	projectId string
	policyId string
	serviceId string
}


func (r ApiIamProjectPolicyServiceGetRequest) Execute() (ResourceService, *_nethttp.Response, error) {
	return r.ApiService.IamProjectPolicyServiceGetExecute(r)
}

/*
 * IamProjectPolicyServiceGet Get iam/policy.service
 * Get iam/policy.service
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param policyId Policy Id
 * @param serviceId serviceId
 * @return ApiIamProjectPolicyServiceGetRequest
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyServiceGet(ctx _context.Context, projectId string, policyId string, serviceId string) ApiIamProjectPolicyServiceGetRequest {
	return ApiIamProjectPolicyServiceGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		policyId: policyId,
		serviceId: serviceId,
	}
}

/*
 * Execute executes the request
 * @return ResourceService
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyServiceGetExecute(r ApiIamProjectPolicyServiceGetRequest) (ResourceService, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResourceService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamProjectPolicyApiService.IamProjectPolicyServiceGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/project/{projectId}/policy/{policyId}/service/{serviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.PathEscape(parameterToString(r.policyId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serviceId"+"}", _neturl.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamProjectPolicyServiceListRequest struct {
	ctx _context.Context
	ApiService *IamProjectPolicyApiService
	projectId string
	policyId string
}


func (r ApiIamProjectPolicyServiceListRequest) Execute() ([]ResourceService, *_nethttp.Response, error) {
	return r.ApiService.IamProjectPolicyServiceListExecute(r)
}

/*
 * IamProjectPolicyServiceList List iam/policy.service
 * List iam/policy.service
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param policyId Policy Id
 * @return ApiIamProjectPolicyServiceListRequest
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyServiceList(ctx _context.Context, projectId string, policyId string) ApiIamProjectPolicyServiceListRequest {
	return ApiIamProjectPolicyServiceListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		policyId: policyId,
	}
}

/*
 * Execute executes the request
 * @return []ResourceService
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyServiceListExecute(r ApiIamProjectPolicyServiceListRequest) ([]ResourceService, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ResourceService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamProjectPolicyApiService.IamProjectPolicyServiceList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/project/{projectId}/policy/{policyId}/service"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.PathEscape(parameterToString(r.policyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamProjectPolicyTagCreateRequest struct {
	ctx _context.Context
	ApiService *IamProjectPolicyApiService
	projectId string
	policyId string
	tag *Tag
}

func (r ApiIamProjectPolicyTagCreateRequest) Tag(tag Tag) ApiIamProjectPolicyTagCreateRequest {
	r.tag = &tag
	return r
}

func (r ApiIamProjectPolicyTagCreateRequest) Execute() (Tag, *_nethttp.Response, error) {
	return r.ApiService.IamProjectPolicyTagCreateExecute(r)
}

/*
 * IamProjectPolicyTagCreate Create iam/policy.tag
 * Create iam/policy.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param policyId Policy Id
 * @return ApiIamProjectPolicyTagCreateRequest
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyTagCreate(ctx _context.Context, projectId string, policyId string) ApiIamProjectPolicyTagCreateRequest {
	return ApiIamProjectPolicyTagCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		policyId: policyId,
	}
}

/*
 * Execute executes the request
 * @return Tag
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyTagCreateExecute(r ApiIamProjectPolicyTagCreateRequest) (Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamProjectPolicyApiService.IamProjectPolicyTagCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/project/{projectId}/policy/{policyId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.PathEscape(parameterToString(r.policyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.tag == nil {
		return localVarReturnValue, nil, reportError("tag is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tag
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamProjectPolicyTagDeleteRequest struct {
	ctx _context.Context
	ApiService *IamProjectPolicyApiService
	projectId string
	policyId string
	tagId string
}


func (r ApiIamProjectPolicyTagDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IamProjectPolicyTagDeleteExecute(r)
}

/*
 * IamProjectPolicyTagDelete Delete iam/policy.tag
 * Delete iam/policy.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param policyId Policy Id
 * @param tagId tagId
 * @return ApiIamProjectPolicyTagDeleteRequest
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyTagDelete(ctx _context.Context, projectId string, policyId string, tagId string) ApiIamProjectPolicyTagDeleteRequest {
	return ApiIamProjectPolicyTagDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		policyId: policyId,
		tagId: tagId,
	}
}

/*
 * Execute executes the request
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyTagDeleteExecute(r ApiIamProjectPolicyTagDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamProjectPolicyApiService.IamProjectPolicyTagDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/project/{projectId}/policy/{policyId}/tag/{tagId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.PathEscape(parameterToString(r.policyId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", _neturl.PathEscape(parameterToString(r.tagId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIamProjectPolicyTagGetRequest struct {
	ctx _context.Context
	ApiService *IamProjectPolicyApiService
	projectId string
	policyId string
	tagId string
}


func (r ApiIamProjectPolicyTagGetRequest) Execute() (Tag, *_nethttp.Response, error) {
	return r.ApiService.IamProjectPolicyTagGetExecute(r)
}

/*
 * IamProjectPolicyTagGet Get iam/policy.tag
 * Get iam/policy.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param policyId Policy Id
 * @param tagId tagId
 * @return ApiIamProjectPolicyTagGetRequest
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyTagGet(ctx _context.Context, projectId string, policyId string, tagId string) ApiIamProjectPolicyTagGetRequest {
	return ApiIamProjectPolicyTagGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		policyId: policyId,
		tagId: tagId,
	}
}

/*
 * Execute executes the request
 * @return Tag
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyTagGetExecute(r ApiIamProjectPolicyTagGetRequest) (Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamProjectPolicyApiService.IamProjectPolicyTagGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/project/{projectId}/policy/{policyId}/tag/{tagId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.PathEscape(parameterToString(r.policyId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", _neturl.PathEscape(parameterToString(r.tagId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamProjectPolicyTagListRequest struct {
	ctx _context.Context
	ApiService *IamProjectPolicyApiService
	projectId string
	policyId string
}


func (r ApiIamProjectPolicyTagListRequest) Execute() ([]Tag, *_nethttp.Response, error) {
	return r.ApiService.IamProjectPolicyTagListExecute(r)
}

/*
 * IamProjectPolicyTagList List iam/policy.tag
 * List iam/policy.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param policyId Policy Id
 * @return ApiIamProjectPolicyTagListRequest
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyTagList(ctx _context.Context, projectId string, policyId string) ApiIamProjectPolicyTagListRequest {
	return ApiIamProjectPolicyTagListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		policyId: policyId,
	}
}

/*
 * Execute executes the request
 * @return []Tag
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyTagListExecute(r ApiIamProjectPolicyTagListRequest) ([]Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamProjectPolicyApiService.IamProjectPolicyTagList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/project/{projectId}/policy/{policyId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.PathEscape(parameterToString(r.policyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamProjectPolicyTagPutRequest struct {
	ctx _context.Context
	ApiService *IamProjectPolicyApiService
	projectId string
	policyId string
	tag *[]Tag
}

func (r ApiIamProjectPolicyTagPutRequest) Tag(tag []Tag) ApiIamProjectPolicyTagPutRequest {
	r.tag = &tag
	return r
}

func (r ApiIamProjectPolicyTagPutRequest) Execute() ([]Tag, *_nethttp.Response, error) {
	return r.ApiService.IamProjectPolicyTagPutExecute(r)
}

/*
 * IamProjectPolicyTagPut Replace iam/policy.tag
 * Replace iam/policy.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param policyId Policy Id
 * @return ApiIamProjectPolicyTagPutRequest
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyTagPut(ctx _context.Context, projectId string, policyId string) ApiIamProjectPolicyTagPutRequest {
	return ApiIamProjectPolicyTagPutRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		policyId: policyId,
	}
}

/*
 * Execute executes the request
 * @return []Tag
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyTagPutExecute(r ApiIamProjectPolicyTagPutRequest) ([]Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamProjectPolicyApiService.IamProjectPolicyTagPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/project/{projectId}/policy/{policyId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.PathEscape(parameterToString(r.policyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.tag == nil {
		return localVarReturnValue, nil, reportError("tag is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tag
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamProjectPolicyUpdateRequest struct {
	ctx _context.Context
	ApiService *IamProjectPolicyApiService
	projectId string
	policyId string
	iamProjectPolicyUpdate *IamProjectPolicyUpdate
}

func (r ApiIamProjectPolicyUpdateRequest) IamProjectPolicyUpdate(iamProjectPolicyUpdate IamProjectPolicyUpdate) ApiIamProjectPolicyUpdateRequest {
	r.iamProjectPolicyUpdate = &iamProjectPolicyUpdate
	return r
}

func (r ApiIamProjectPolicyUpdateRequest) Execute() (Policy, *_nethttp.Response, error) {
	return r.ApiService.IamProjectPolicyUpdateExecute(r)
}

/*
 * IamProjectPolicyUpdate Update iam/policy
 * Returns modified policy
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param policyId Policy Id
 * @return ApiIamProjectPolicyUpdateRequest
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyUpdate(ctx _context.Context, projectId string, policyId string) ApiIamProjectPolicyUpdateRequest {
	return ApiIamProjectPolicyUpdateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		policyId: policyId,
	}
}

/*
 * Execute executes the request
 * @return Policy
 */
func (a *IamProjectPolicyApiService) IamProjectPolicyUpdateExecute(r ApiIamProjectPolicyUpdateRequest) (Policy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Policy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamProjectPolicyApiService.IamProjectPolicyUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/project/{projectId}/policy/{policyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.PathEscape(parameterToString(r.policyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.iamProjectPolicyUpdate == nil {
		return localVarReturnValue, nil, reportError("iamProjectPolicyUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iamProjectPolicyUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
