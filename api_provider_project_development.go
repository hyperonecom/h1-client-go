/*
 * HyperOne
 *
 * HyperOne API
 *
 * API version: 0.1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package h1

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ProviderProjectDevelopmentApiService ProviderProjectDevelopmentApi service
type ProviderProjectDevelopmentApiService service

type ApiProviderProjectDevelopmentConnectGetRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	connectId string
}


func (r ApiProviderProjectDevelopmentConnectGetRequest) Execute() (ResourceConnect, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentConnectGetExecute(r)
}

/*
 * ProviderProjectDevelopmentConnectGet Get provider/development.connect
 * Get provider/development.connect
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @param connectId connectId
 * @return ApiProviderProjectDevelopmentConnectGetRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentConnectGet(ctx _context.Context, projectId string, locationId string, developmentId string, connectId string) ApiProviderProjectDevelopmentConnectGetRequest {
	return ApiProviderProjectDevelopmentConnectGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
		connectId: connectId,
	}
}

/*
 * Execute executes the request
 * @return ResourceConnect
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentConnectGetExecute(r ApiProviderProjectDevelopmentConnectGetRequest) (ResourceConnect, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResourceConnect
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentConnectGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/connect/{connectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectId"+"}", _neturl.PathEscape(parameterToString(r.connectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentConnectListRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
}


func (r ApiProviderProjectDevelopmentConnectListRequest) Execute() ([]ResourceConnect, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentConnectListExecute(r)
}

/*
 * ProviderProjectDevelopmentConnectList List provider/development.connect
 * List provider/development.connect
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentConnectListRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentConnectList(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentConnectListRequest {
	return ApiProviderProjectDevelopmentConnectListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return []ResourceConnect
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentConnectListExecute(r ApiProviderProjectDevelopmentConnectListRequest) ([]ResourceConnect, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ResourceConnect
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentConnectList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/connect"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentCreateRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	providerProjectDevelopmentCreate *ProviderProjectDevelopmentCreate
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiProviderProjectDevelopmentCreateRequest) ProviderProjectDevelopmentCreate(providerProjectDevelopmentCreate ProviderProjectDevelopmentCreate) ApiProviderProjectDevelopmentCreateRequest {
	r.providerProjectDevelopmentCreate = &providerProjectDevelopmentCreate
	return r
}
func (r ApiProviderProjectDevelopmentCreateRequest) XIdempotencyKey(xIdempotencyKey string) ApiProviderProjectDevelopmentCreateRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
func (r ApiProviderProjectDevelopmentCreateRequest) XDryRun(xDryRun string) ApiProviderProjectDevelopmentCreateRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiProviderProjectDevelopmentCreateRequest) Execute() (Development, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentCreateExecute(r)
}

/*
 * ProviderProjectDevelopmentCreate Create provider/development
 * Create development
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @return ApiProviderProjectDevelopmentCreateRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentCreate(ctx _context.Context, projectId string, locationId string) ApiProviderProjectDevelopmentCreateRequest {
	return ApiProviderProjectDevelopmentCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
	}
}

/*
 * Execute executes the request
 * @return Development
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentCreateExecute(r ApiProviderProjectDevelopmentCreateRequest) (Development, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Development
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.providerProjectDevelopmentCreate == nil {
		return localVarReturnValue, nil, reportError("providerProjectDevelopmentCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	// body params
	localVarPostBody = r.providerProjectDevelopmentCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentCredentialCreateRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	developmentCredential *DevelopmentCredential
}

func (r ApiProviderProjectDevelopmentCredentialCreateRequest) DevelopmentCredential(developmentCredential DevelopmentCredential) ApiProviderProjectDevelopmentCredentialCreateRequest {
	r.developmentCredential = &developmentCredential
	return r
}

func (r ApiProviderProjectDevelopmentCredentialCreateRequest) Execute() (DevelopmentCredential, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentCredentialCreateExecute(r)
}

/*
 * ProviderProjectDevelopmentCredentialCreate Create provider/development.credential
 * Create provider/development.credential
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentCredentialCreateRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentCredentialCreate(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentCredentialCreateRequest {
	return ApiProviderProjectDevelopmentCredentialCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return DevelopmentCredential
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentCredentialCreateExecute(r ApiProviderProjectDevelopmentCredentialCreateRequest) (DevelopmentCredential, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DevelopmentCredential
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentCredentialCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/credential"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.developmentCredential == nil {
		return localVarReturnValue, nil, reportError("developmentCredential is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.developmentCredential
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentCredentialDeleteRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	credentialId string
}


func (r ApiProviderProjectDevelopmentCredentialDeleteRequest) Execute() (Development, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentCredentialDeleteExecute(r)
}

/*
 * ProviderProjectDevelopmentCredentialDelete Delete provider/development.credential
 * Delete provider/development.credential
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @param credentialId credentialId
 * @return ApiProviderProjectDevelopmentCredentialDeleteRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentCredentialDelete(ctx _context.Context, projectId string, locationId string, developmentId string, credentialId string) ApiProviderProjectDevelopmentCredentialDeleteRequest {
	return ApiProviderProjectDevelopmentCredentialDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
		credentialId: credentialId,
	}
}

/*
 * Execute executes the request
 * @return Development
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentCredentialDeleteExecute(r ApiProviderProjectDevelopmentCredentialDeleteRequest) (Development, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Development
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentCredentialDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/credential/{credentialId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"credentialId"+"}", _neturl.PathEscape(parameterToString(r.credentialId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentCredentialGetRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	credentialId string
}


func (r ApiProviderProjectDevelopmentCredentialGetRequest) Execute() (DevelopmentCredential, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentCredentialGetExecute(r)
}

/*
 * ProviderProjectDevelopmentCredentialGet Get provider/development.credential
 * Get provider/development.credential
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @param credentialId credentialId
 * @return ApiProviderProjectDevelopmentCredentialGetRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentCredentialGet(ctx _context.Context, projectId string, locationId string, developmentId string, credentialId string) ApiProviderProjectDevelopmentCredentialGetRequest {
	return ApiProviderProjectDevelopmentCredentialGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
		credentialId: credentialId,
	}
}

/*
 * Execute executes the request
 * @return DevelopmentCredential
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentCredentialGetExecute(r ApiProviderProjectDevelopmentCredentialGetRequest) (DevelopmentCredential, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DevelopmentCredential
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentCredentialGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/credential/{credentialId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"credentialId"+"}", _neturl.PathEscape(parameterToString(r.credentialId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentCredentialListRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
}


func (r ApiProviderProjectDevelopmentCredentialListRequest) Execute() ([]DevelopmentCredential, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentCredentialListExecute(r)
}

/*
 * ProviderProjectDevelopmentCredentialList List provider/development.credential
 * List provider/development.credential
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentCredentialListRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentCredentialList(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentCredentialListRequest {
	return ApiProviderProjectDevelopmentCredentialListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return []DevelopmentCredential
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentCredentialListExecute(r ApiProviderProjectDevelopmentCredentialListRequest) ([]DevelopmentCredential, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []DevelopmentCredential
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentCredentialList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/credential"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentCredentialPatchRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	credentialId string
	providerProjectDevelopmentCredentialPatch *ProviderProjectDevelopmentCredentialPatch
}

func (r ApiProviderProjectDevelopmentCredentialPatchRequest) ProviderProjectDevelopmentCredentialPatch(providerProjectDevelopmentCredentialPatch ProviderProjectDevelopmentCredentialPatch) ApiProviderProjectDevelopmentCredentialPatchRequest {
	r.providerProjectDevelopmentCredentialPatch = &providerProjectDevelopmentCredentialPatch
	return r
}

func (r ApiProviderProjectDevelopmentCredentialPatchRequest) Execute() (DevelopmentCredential, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentCredentialPatchExecute(r)
}

/*
 * ProviderProjectDevelopmentCredentialPatch Update provider/development.credential
 * Update provider/development.credential
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @param credentialId credentialId
 * @return ApiProviderProjectDevelopmentCredentialPatchRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentCredentialPatch(ctx _context.Context, projectId string, locationId string, developmentId string, credentialId string) ApiProviderProjectDevelopmentCredentialPatchRequest {
	return ApiProviderProjectDevelopmentCredentialPatchRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
		credentialId: credentialId,
	}
}

/*
 * Execute executes the request
 * @return DevelopmentCredential
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentCredentialPatchExecute(r ApiProviderProjectDevelopmentCredentialPatchRequest) (DevelopmentCredential, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DevelopmentCredential
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentCredentialPatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/credential/{credentialId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"credentialId"+"}", _neturl.PathEscape(parameterToString(r.credentialId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.providerProjectDevelopmentCredentialPatch == nil {
		return localVarReturnValue, nil, reportError("providerProjectDevelopmentCredentialPatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.providerProjectDevelopmentCredentialPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentDeleteRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
}


func (r ApiProviderProjectDevelopmentDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentDeleteExecute(r)
}

/*
 * ProviderProjectDevelopmentDelete Delete provider/development
 * Delete development
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentDeleteRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentDelete(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentDeleteRequest {
	return ApiProviderProjectDevelopmentDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentDeleteExecute(r ApiProviderProjectDevelopmentDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentDomainCreateRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	domain *Domain
}

func (r ApiProviderProjectDevelopmentDomainCreateRequest) Domain(domain Domain) ApiProviderProjectDevelopmentDomainCreateRequest {
	r.domain = &domain
	return r
}

func (r ApiProviderProjectDevelopmentDomainCreateRequest) Execute() (Domain, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentDomainCreateExecute(r)
}

/*
 * ProviderProjectDevelopmentDomainCreate Create provider/development.domain
 * Create provider/development.domain
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentDomainCreateRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentDomainCreate(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentDomainCreateRequest {
	return ApiProviderProjectDevelopmentDomainCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return Domain
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentDomainCreateExecute(r ApiProviderProjectDevelopmentDomainCreateRequest) (Domain, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Domain
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentDomainCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/domain"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.domain == nil {
		return localVarReturnValue, nil, reportError("domain is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.domain
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentDomainDeleteRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	domainId string
}


func (r ApiProviderProjectDevelopmentDomainDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentDomainDeleteExecute(r)
}

/*
 * ProviderProjectDevelopmentDomainDelete Delete provider/development.domain
 * Delete provider/development.domain
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @param domainId domainId
 * @return ApiProviderProjectDevelopmentDomainDeleteRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentDomainDelete(ctx _context.Context, projectId string, locationId string, developmentId string, domainId string) ApiProviderProjectDevelopmentDomainDeleteRequest {
	return ApiProviderProjectDevelopmentDomainDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
		domainId: domainId,
	}
}

/*
 * Execute executes the request
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentDomainDeleteExecute(r ApiProviderProjectDevelopmentDomainDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentDomainDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/domain/{domainId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"domainId"+"}", _neturl.PathEscape(parameterToString(r.domainId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentDomainGetRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	domainId string
}


func (r ApiProviderProjectDevelopmentDomainGetRequest) Execute() (Domain, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentDomainGetExecute(r)
}

/*
 * ProviderProjectDevelopmentDomainGet Get provider/development.domain
 * Get provider/development.domain
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @param domainId domainId
 * @return ApiProviderProjectDevelopmentDomainGetRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentDomainGet(ctx _context.Context, projectId string, locationId string, developmentId string, domainId string) ApiProviderProjectDevelopmentDomainGetRequest {
	return ApiProviderProjectDevelopmentDomainGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
		domainId: domainId,
	}
}

/*
 * Execute executes the request
 * @return Domain
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentDomainGetExecute(r ApiProviderProjectDevelopmentDomainGetRequest) (Domain, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Domain
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentDomainGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/domain/{domainId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"domainId"+"}", _neturl.PathEscape(parameterToString(r.domainId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentDomainListRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
}


func (r ApiProviderProjectDevelopmentDomainListRequest) Execute() ([]Domain, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentDomainListExecute(r)
}

/*
 * ProviderProjectDevelopmentDomainList List provider/development.domain
 * List provider/development.domain
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentDomainListRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentDomainList(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentDomainListRequest {
	return ApiProviderProjectDevelopmentDomainListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return []Domain
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentDomainListExecute(r ApiProviderProjectDevelopmentDomainListRequest) ([]Domain, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Domain
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentDomainList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/domain"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentEnvCreateRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	providerEnv *ProviderEnv
}

func (r ApiProviderProjectDevelopmentEnvCreateRequest) ProviderEnv(providerEnv ProviderEnv) ApiProviderProjectDevelopmentEnvCreateRequest {
	r.providerEnv = &providerEnv
	return r
}

func (r ApiProviderProjectDevelopmentEnvCreateRequest) Execute() (ProviderEnv, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentEnvCreateExecute(r)
}

/*
 * ProviderProjectDevelopmentEnvCreate Create provider/development.env
 * Create provider/development.env
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentEnvCreateRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentEnvCreate(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentEnvCreateRequest {
	return ApiProviderProjectDevelopmentEnvCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return ProviderEnv
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentEnvCreateExecute(r ApiProviderProjectDevelopmentEnvCreateRequest) (ProviderEnv, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProviderEnv
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentEnvCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/env"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.providerEnv == nil {
		return localVarReturnValue, nil, reportError("providerEnv is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.providerEnv
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentEnvDeleteRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	envId string
}


func (r ApiProviderProjectDevelopmentEnvDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentEnvDeleteExecute(r)
}

/*
 * ProviderProjectDevelopmentEnvDelete Delete provider/development.env
 * Delete provider/development.env
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @param envId envId
 * @return ApiProviderProjectDevelopmentEnvDeleteRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentEnvDelete(ctx _context.Context, projectId string, locationId string, developmentId string, envId string) ApiProviderProjectDevelopmentEnvDeleteRequest {
	return ApiProviderProjectDevelopmentEnvDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
		envId: envId,
	}
}

/*
 * Execute executes the request
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentEnvDeleteExecute(r ApiProviderProjectDevelopmentEnvDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentEnvDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/env/{envId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envId"+"}", _neturl.PathEscape(parameterToString(r.envId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentEnvGetRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	envId string
}


func (r ApiProviderProjectDevelopmentEnvGetRequest) Execute() (ProviderEnv, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentEnvGetExecute(r)
}

/*
 * ProviderProjectDevelopmentEnvGet Get provider/development.env
 * Get provider/development.env
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @param envId envId
 * @return ApiProviderProjectDevelopmentEnvGetRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentEnvGet(ctx _context.Context, projectId string, locationId string, developmentId string, envId string) ApiProviderProjectDevelopmentEnvGetRequest {
	return ApiProviderProjectDevelopmentEnvGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
		envId: envId,
	}
}

/*
 * Execute executes the request
 * @return ProviderEnv
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentEnvGetExecute(r ApiProviderProjectDevelopmentEnvGetRequest) (ProviderEnv, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProviderEnv
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentEnvGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/env/{envId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"envId"+"}", _neturl.PathEscape(parameterToString(r.envId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentEnvListRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
}


func (r ApiProviderProjectDevelopmentEnvListRequest) Execute() ([]ProviderEnv, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentEnvListExecute(r)
}

/*
 * ProviderProjectDevelopmentEnvList List provider/development.env
 * List provider/development.env
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentEnvListRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentEnvList(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentEnvListRequest {
	return ApiProviderProjectDevelopmentEnvListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return []ProviderEnv
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentEnvListExecute(r ApiProviderProjectDevelopmentEnvListRequest) ([]ProviderEnv, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ProviderEnv
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentEnvList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/env"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentEventGetRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	eventId string
}


func (r ApiProviderProjectDevelopmentEventGetRequest) Execute() (Event, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentEventGetExecute(r)
}

/*
 * ProviderProjectDevelopmentEventGet Get provider/development.event
 * Get provider/development.event
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @param eventId eventId
 * @return ApiProviderProjectDevelopmentEventGetRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentEventGet(ctx _context.Context, projectId string, locationId string, developmentId string, eventId string) ApiProviderProjectDevelopmentEventGetRequest {
	return ApiProviderProjectDevelopmentEventGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
		eventId: eventId,
	}
}

/*
 * Execute executes the request
 * @return Event
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentEventGetExecute(r ApiProviderProjectDevelopmentEventGetRequest) (Event, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentEventGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/event/{eventId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentEventListRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	limit *float32
	skip *float32
}

func (r ApiProviderProjectDevelopmentEventListRequest) Limit(limit float32) ApiProviderProjectDevelopmentEventListRequest {
	r.limit = &limit
	return r
}
func (r ApiProviderProjectDevelopmentEventListRequest) Skip(skip float32) ApiProviderProjectDevelopmentEventListRequest {
	r.skip = &skip
	return r
}

func (r ApiProviderProjectDevelopmentEventListRequest) Execute() ([]Event, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentEventListExecute(r)
}

/*
 * ProviderProjectDevelopmentEventList List provider/development.event
 * List provider/development.event
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentEventListRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentEventList(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentEventListRequest {
	return ApiProviderProjectDevelopmentEventListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return []Event
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentEventListExecute(r ApiProviderProjectDevelopmentEventListRequest) ([]Event, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentEventList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/event"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("$limit", parameterToString(*r.limit, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentGetRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
}


func (r ApiProviderProjectDevelopmentGetRequest) Execute() (Development, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentGetExecute(r)
}

/*
 * ProviderProjectDevelopmentGet Get provider/development
 * Returns a single development
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentGetRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentGet(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentGetRequest {
	return ApiProviderProjectDevelopmentGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return Development
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentGetExecute(r ApiProviderProjectDevelopmentGetRequest) (Development, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Development
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentLinkCreateRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	providerLink *ProviderLink
}

func (r ApiProviderProjectDevelopmentLinkCreateRequest) ProviderLink(providerLink ProviderLink) ApiProviderProjectDevelopmentLinkCreateRequest {
	r.providerLink = &providerLink
	return r
}

func (r ApiProviderProjectDevelopmentLinkCreateRequest) Execute() (ProviderLink, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentLinkCreateExecute(r)
}

/*
 * ProviderProjectDevelopmentLinkCreate Create provider/development.link
 * Create provider/development.link
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentLinkCreateRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentLinkCreate(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentLinkCreateRequest {
	return ApiProviderProjectDevelopmentLinkCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return ProviderLink
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentLinkCreateExecute(r ApiProviderProjectDevelopmentLinkCreateRequest) (ProviderLink, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProviderLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentLinkCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/link"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.providerLink == nil {
		return localVarReturnValue, nil, reportError("providerLink is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.providerLink
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentLinkDeleteRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	linkId string
}


func (r ApiProviderProjectDevelopmentLinkDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentLinkDeleteExecute(r)
}

/*
 * ProviderProjectDevelopmentLinkDelete Delete provider/development.link
 * Delete provider/development.link
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @param linkId linkId
 * @return ApiProviderProjectDevelopmentLinkDeleteRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentLinkDelete(ctx _context.Context, projectId string, locationId string, developmentId string, linkId string) ApiProviderProjectDevelopmentLinkDeleteRequest {
	return ApiProviderProjectDevelopmentLinkDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
		linkId: linkId,
	}
}

/*
 * Execute executes the request
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentLinkDeleteExecute(r ApiProviderProjectDevelopmentLinkDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentLinkDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/link/{linkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"linkId"+"}", _neturl.PathEscape(parameterToString(r.linkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentLinkGetRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	linkId string
}


func (r ApiProviderProjectDevelopmentLinkGetRequest) Execute() (ProviderLink, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentLinkGetExecute(r)
}

/*
 * ProviderProjectDevelopmentLinkGet Get provider/development.link
 * Get provider/development.link
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @param linkId linkId
 * @return ApiProviderProjectDevelopmentLinkGetRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentLinkGet(ctx _context.Context, projectId string, locationId string, developmentId string, linkId string) ApiProviderProjectDevelopmentLinkGetRequest {
	return ApiProviderProjectDevelopmentLinkGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
		linkId: linkId,
	}
}

/*
 * Execute executes the request
 * @return ProviderLink
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentLinkGetExecute(r ApiProviderProjectDevelopmentLinkGetRequest) (ProviderLink, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProviderLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentLinkGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/link/{linkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"linkId"+"}", _neturl.PathEscape(parameterToString(r.linkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentLinkListRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
}


func (r ApiProviderProjectDevelopmentLinkListRequest) Execute() ([]ProviderLink, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentLinkListExecute(r)
}

/*
 * ProviderProjectDevelopmentLinkList List provider/development.link
 * List provider/development.link
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentLinkListRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentLinkList(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentLinkListRequest {
	return ApiProviderProjectDevelopmentLinkListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return []ProviderLink
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentLinkListExecute(r ApiProviderProjectDevelopmentLinkListRequest) ([]ProviderLink, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ProviderLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentLinkList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/link"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentListRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	name *string
	tagValue *string
	tagKey *string
}

func (r ApiProviderProjectDevelopmentListRequest) Name(name string) ApiProviderProjectDevelopmentListRequest {
	r.name = &name
	return r
}
func (r ApiProviderProjectDevelopmentListRequest) TagValue(tagValue string) ApiProviderProjectDevelopmentListRequest {
	r.tagValue = &tagValue
	return r
}
func (r ApiProviderProjectDevelopmentListRequest) TagKey(tagKey string) ApiProviderProjectDevelopmentListRequest {
	r.tagKey = &tagKey
	return r
}

func (r ApiProviderProjectDevelopmentListRequest) Execute() ([]Development, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentListExecute(r)
}

/*
 * ProviderProjectDevelopmentList List provider/development
 * List development
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @return ApiProviderProjectDevelopmentListRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentList(ctx _context.Context, projectId string, locationId string) ApiProviderProjectDevelopmentListRequest {
	return ApiProviderProjectDevelopmentListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
	}
}

/*
 * Execute executes the request
 * @return []Development
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentListExecute(r ApiProviderProjectDevelopmentListRequest) ([]Development, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Development
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.tagValue != nil {
		localVarQueryParams.Add("tag.value", parameterToString(*r.tagValue, ""))
	}
	if r.tagKey != nil {
		localVarQueryParams.Add("tag.key", parameterToString(*r.tagKey, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentLogGetRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	logId string
}


func (r ApiProviderProjectDevelopmentLogGetRequest) Execute() (ProviderLog, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentLogGetExecute(r)
}

/*
 * ProviderProjectDevelopmentLogGet Get provider/development.log
 * Get provider/development.log
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @param logId logId
 * @return ApiProviderProjectDevelopmentLogGetRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentLogGet(ctx _context.Context, projectId string, locationId string, developmentId string, logId string) ApiProviderProjectDevelopmentLogGetRequest {
	return ApiProviderProjectDevelopmentLogGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
		logId: logId,
	}
}

/*
 * Execute executes the request
 * @return ProviderLog
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentLogGetExecute(r ApiProviderProjectDevelopmentLogGetRequest) (ProviderLog, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProviderLog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentLogGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/log/{logId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"logId"+"}", _neturl.PathEscape(parameterToString(r.logId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentLogListRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
}


func (r ApiProviderProjectDevelopmentLogListRequest) Execute() ([]ProviderLog, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentLogListExecute(r)
}

/*
 * ProviderProjectDevelopmentLogList List provider/development.log
 * List provider/development.log
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentLogListRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentLogList(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentLogListRequest {
	return ApiProviderProjectDevelopmentLogListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return []ProviderLog
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentLogListExecute(r ApiProviderProjectDevelopmentLogListRequest) ([]ProviderLog, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ProviderLog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentLogList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/log"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentLogReadRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	logId string
}


func (r ApiProviderProjectDevelopmentLogReadRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentLogReadExecute(r)
}

/*
 * ProviderProjectDevelopmentLogRead Read provider/development.log
 * action read
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @param logId logId
 * @return ApiProviderProjectDevelopmentLogReadRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentLogRead(ctx _context.Context, projectId string, locationId string, developmentId string, logId string) ApiProviderProjectDevelopmentLogReadRequest {
	return ApiProviderProjectDevelopmentLogReadRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
		logId: logId,
	}
}

/*
 * Execute executes the request
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentLogReadExecute(r ApiProviderProjectDevelopmentLogReadRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentLogRead")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/log/{logId}/actions/read"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"logId"+"}", _neturl.PathEscape(parameterToString(r.logId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentMetricGetRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	metricId string
}


func (r ApiProviderProjectDevelopmentMetricGetRequest) Execute() (Metric, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentMetricGetExecute(r)
}

/*
 * ProviderProjectDevelopmentMetricGet Get provider/development.metric
 * Get provider/development.metric
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @param metricId metricId
 * @return ApiProviderProjectDevelopmentMetricGetRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentMetricGet(ctx _context.Context, projectId string, locationId string, developmentId string, metricId string) ApiProviderProjectDevelopmentMetricGetRequest {
	return ApiProviderProjectDevelopmentMetricGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
		metricId: metricId,
	}
}

/*
 * Execute executes the request
 * @return Metric
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentMetricGetExecute(r ApiProviderProjectDevelopmentMetricGetRequest) (Metric, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Metric
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentMetricGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/metric/{metricId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metricId"+"}", _neturl.PathEscape(parameterToString(r.metricId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentMetricListRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
}


func (r ApiProviderProjectDevelopmentMetricListRequest) Execute() ([]Metric, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentMetricListExecute(r)
}

/*
 * ProviderProjectDevelopmentMetricList List provider/development.metric
 * List provider/development.metric
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentMetricListRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentMetricList(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentMetricListRequest {
	return ApiProviderProjectDevelopmentMetricListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return []Metric
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentMetricListExecute(r ApiProviderProjectDevelopmentMetricListRequest) ([]Metric, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Metric
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentMetricList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/metric"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentMetricPointListRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	metricId string
	interval *string
	timespan *string
}

func (r ApiProviderProjectDevelopmentMetricPointListRequest) Interval(interval string) ApiProviderProjectDevelopmentMetricPointListRequest {
	r.interval = &interval
	return r
}
func (r ApiProviderProjectDevelopmentMetricPointListRequest) Timespan(timespan string) ApiProviderProjectDevelopmentMetricPointListRequest {
	r.timespan = &timespan
	return r
}

func (r ApiProviderProjectDevelopmentMetricPointListRequest) Execute() ([]Point, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentMetricPointListExecute(r)
}

/*
 * ProviderProjectDevelopmentMetricPointList List provider/development.point
 * List provider/development.point
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @param metricId metricId
 * @return ApiProviderProjectDevelopmentMetricPointListRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentMetricPointList(ctx _context.Context, projectId string, locationId string, developmentId string, metricId string) ApiProviderProjectDevelopmentMetricPointListRequest {
	return ApiProviderProjectDevelopmentMetricPointListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
		metricId: metricId,
	}
}

/*
 * Execute executes the request
 * @return []Point
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentMetricPointListExecute(r ApiProviderProjectDevelopmentMetricPointListRequest) ([]Point, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Point
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentMetricPointList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/metric/{metricId}/point"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metricId"+"}", _neturl.PathEscape(parameterToString(r.metricId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.interval != nil {
		localVarQueryParams.Add("interval", parameterToString(*r.interval, ""))
	}
	if r.timespan != nil {
		localVarQueryParams.Add("timespan", parameterToString(*r.timespan, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentRestartRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiProviderProjectDevelopmentRestartRequest) XIdempotencyKey(xIdempotencyKey string) ApiProviderProjectDevelopmentRestartRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
func (r ApiProviderProjectDevelopmentRestartRequest) XDryRun(xDryRun string) ApiProviderProjectDevelopmentRestartRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiProviderProjectDevelopmentRestartRequest) Execute() (Development, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentRestartExecute(r)
}

/*
 * ProviderProjectDevelopmentRestart Restart provider/development
 * action restart
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentRestartRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentRestart(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentRestartRequest {
	return ApiProviderProjectDevelopmentRestartRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return Development
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentRestartExecute(r ApiProviderProjectDevelopmentRestartRequest) (Development, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Development
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentRestart")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/actions/restart"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentServiceGetRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	serviceId string
}


func (r ApiProviderProjectDevelopmentServiceGetRequest) Execute() (ResourceService, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentServiceGetExecute(r)
}

/*
 * ProviderProjectDevelopmentServiceGet Get provider/development.service
 * Get provider/development.service
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @param serviceId serviceId
 * @return ApiProviderProjectDevelopmentServiceGetRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentServiceGet(ctx _context.Context, projectId string, locationId string, developmentId string, serviceId string) ApiProviderProjectDevelopmentServiceGetRequest {
	return ApiProviderProjectDevelopmentServiceGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
		serviceId: serviceId,
	}
}

/*
 * Execute executes the request
 * @return ResourceService
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentServiceGetExecute(r ApiProviderProjectDevelopmentServiceGetRequest) (ResourceService, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResourceService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentServiceGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/service/{serviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serviceId"+"}", _neturl.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentServiceListRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
}


func (r ApiProviderProjectDevelopmentServiceListRequest) Execute() ([]ResourceService, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentServiceListExecute(r)
}

/*
 * ProviderProjectDevelopmentServiceList List provider/development.service
 * List provider/development.service
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentServiceListRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentServiceList(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentServiceListRequest {
	return ApiProviderProjectDevelopmentServiceListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return []ResourceService
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentServiceListExecute(r ApiProviderProjectDevelopmentServiceListRequest) ([]ResourceService, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ResourceService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentServiceList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/service"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentSideappGetRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	sideappId string
}


func (r ApiProviderProjectDevelopmentSideappGetRequest) Execute() (ProviderSideapp, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentSideappGetExecute(r)
}

/*
 * ProviderProjectDevelopmentSideappGet Get provider/development.sideapp
 * Get provider/development.sideapp
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @param sideappId sideappId
 * @return ApiProviderProjectDevelopmentSideappGetRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentSideappGet(ctx _context.Context, projectId string, locationId string, developmentId string, sideappId string) ApiProviderProjectDevelopmentSideappGetRequest {
	return ApiProviderProjectDevelopmentSideappGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
		sideappId: sideappId,
	}
}

/*
 * Execute executes the request
 * @return ProviderSideapp
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentSideappGetExecute(r ApiProviderProjectDevelopmentSideappGetRequest) (ProviderSideapp, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProviderSideapp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentSideappGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/sideapp/{sideappId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sideappId"+"}", _neturl.PathEscape(parameterToString(r.sideappId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentSideappListRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
}


func (r ApiProviderProjectDevelopmentSideappListRequest) Execute() ([]ProviderSideapp, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentSideappListExecute(r)
}

/*
 * ProviderProjectDevelopmentSideappList List provider/development.sideapp
 * List provider/development.sideapp
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentSideappListRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentSideappList(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentSideappListRequest {
	return ApiProviderProjectDevelopmentSideappListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return []ProviderSideapp
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentSideappListExecute(r ApiProviderProjectDevelopmentSideappListRequest) ([]ProviderSideapp, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ProviderSideapp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentSideappList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/sideapp"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentSideappOpenRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	sideappId string
}


func (r ApiProviderProjectDevelopmentSideappOpenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentSideappOpenExecute(r)
}

/*
 * ProviderProjectDevelopmentSideappOpen Open provider/development.sideapp
 * action open
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @param sideappId sideappId
 * @return ApiProviderProjectDevelopmentSideappOpenRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentSideappOpen(ctx _context.Context, projectId string, locationId string, developmentId string, sideappId string) ApiProviderProjectDevelopmentSideappOpenRequest {
	return ApiProviderProjectDevelopmentSideappOpenRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
		sideappId: sideappId,
	}
}

/*
 * Execute executes the request
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentSideappOpenExecute(r ApiProviderProjectDevelopmentSideappOpenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentSideappOpen")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/sideapp/{sideappId}/actions/open"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sideappId"+"}", _neturl.PathEscape(parameterToString(r.sideappId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentSnapshotCreateRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	providerSnapshot *ProviderSnapshot
}

func (r ApiProviderProjectDevelopmentSnapshotCreateRequest) ProviderSnapshot(providerSnapshot ProviderSnapshot) ApiProviderProjectDevelopmentSnapshotCreateRequest {
	r.providerSnapshot = &providerSnapshot
	return r
}

func (r ApiProviderProjectDevelopmentSnapshotCreateRequest) Execute() (ProviderSnapshot, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentSnapshotCreateExecute(r)
}

/*
 * ProviderProjectDevelopmentSnapshotCreate Create provider/development.snapshot
 * Create provider/development.snapshot
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentSnapshotCreateRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentSnapshotCreate(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentSnapshotCreateRequest {
	return ApiProviderProjectDevelopmentSnapshotCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return ProviderSnapshot
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentSnapshotCreateExecute(r ApiProviderProjectDevelopmentSnapshotCreateRequest) (ProviderSnapshot, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProviderSnapshot
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentSnapshotCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/snapshot"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.providerSnapshot == nil {
		return localVarReturnValue, nil, reportError("providerSnapshot is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.providerSnapshot
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentSnapshotDeleteRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	snapshotId string
}


func (r ApiProviderProjectDevelopmentSnapshotDeleteRequest) Execute() (Development, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentSnapshotDeleteExecute(r)
}

/*
 * ProviderProjectDevelopmentSnapshotDelete Delete provider/development.snapshot
 * Delete provider/development.snapshot
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @param snapshotId snapshotId
 * @return ApiProviderProjectDevelopmentSnapshotDeleteRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentSnapshotDelete(ctx _context.Context, projectId string, locationId string, developmentId string, snapshotId string) ApiProviderProjectDevelopmentSnapshotDeleteRequest {
	return ApiProviderProjectDevelopmentSnapshotDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
		snapshotId: snapshotId,
	}
}

/*
 * Execute executes the request
 * @return Development
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentSnapshotDeleteExecute(r ApiProviderProjectDevelopmentSnapshotDeleteRequest) (Development, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Development
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentSnapshotDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/snapshot/{snapshotId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshotId"+"}", _neturl.PathEscape(parameterToString(r.snapshotId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentSnapshotDownloadRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	snapshotId string
	providerProjectDevelopmentSnapshotDownload *ProviderProjectDevelopmentSnapshotDownload
}

func (r ApiProviderProjectDevelopmentSnapshotDownloadRequest) ProviderProjectDevelopmentSnapshotDownload(providerProjectDevelopmentSnapshotDownload ProviderProjectDevelopmentSnapshotDownload) ApiProviderProjectDevelopmentSnapshotDownloadRequest {
	r.providerProjectDevelopmentSnapshotDownload = &providerProjectDevelopmentSnapshotDownload
	return r
}

func (r ApiProviderProjectDevelopmentSnapshotDownloadRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentSnapshotDownloadExecute(r)
}

/*
 * ProviderProjectDevelopmentSnapshotDownload Download provider/development.snapshot
 * action download
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @param snapshotId snapshotId
 * @return ApiProviderProjectDevelopmentSnapshotDownloadRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentSnapshotDownload(ctx _context.Context, projectId string, locationId string, developmentId string, snapshotId string) ApiProviderProjectDevelopmentSnapshotDownloadRequest {
	return ApiProviderProjectDevelopmentSnapshotDownloadRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
		snapshotId: snapshotId,
	}
}

/*
 * Execute executes the request
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentSnapshotDownloadExecute(r ApiProviderProjectDevelopmentSnapshotDownloadRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentSnapshotDownload")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/snapshot/{snapshotId}/actions/download"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshotId"+"}", _neturl.PathEscape(parameterToString(r.snapshotId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.providerProjectDevelopmentSnapshotDownload == nil {
		return nil, reportError("providerProjectDevelopmentSnapshotDownload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.providerProjectDevelopmentSnapshotDownload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentSnapshotGetRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	snapshotId string
}


func (r ApiProviderProjectDevelopmentSnapshotGetRequest) Execute() (ProviderSnapshot, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentSnapshotGetExecute(r)
}

/*
 * ProviderProjectDevelopmentSnapshotGet Get provider/development.snapshot
 * Get provider/development.snapshot
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @param snapshotId snapshotId
 * @return ApiProviderProjectDevelopmentSnapshotGetRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentSnapshotGet(ctx _context.Context, projectId string, locationId string, developmentId string, snapshotId string) ApiProviderProjectDevelopmentSnapshotGetRequest {
	return ApiProviderProjectDevelopmentSnapshotGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
		snapshotId: snapshotId,
	}
}

/*
 * Execute executes the request
 * @return ProviderSnapshot
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentSnapshotGetExecute(r ApiProviderProjectDevelopmentSnapshotGetRequest) (ProviderSnapshot, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProviderSnapshot
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentSnapshotGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/snapshot/{snapshotId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshotId"+"}", _neturl.PathEscape(parameterToString(r.snapshotId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentSnapshotListRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
}


func (r ApiProviderProjectDevelopmentSnapshotListRequest) Execute() ([]ProviderSnapshot, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentSnapshotListExecute(r)
}

/*
 * ProviderProjectDevelopmentSnapshotList List provider/development.snapshot
 * List provider/development.snapshot
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentSnapshotListRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentSnapshotList(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentSnapshotListRequest {
	return ApiProviderProjectDevelopmentSnapshotListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return []ProviderSnapshot
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentSnapshotListExecute(r ApiProviderProjectDevelopmentSnapshotListRequest) ([]ProviderSnapshot, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ProviderSnapshot
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentSnapshotList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/snapshot"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentStartRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiProviderProjectDevelopmentStartRequest) XIdempotencyKey(xIdempotencyKey string) ApiProviderProjectDevelopmentStartRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
func (r ApiProviderProjectDevelopmentStartRequest) XDryRun(xDryRun string) ApiProviderProjectDevelopmentStartRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiProviderProjectDevelopmentStartRequest) Execute() (Development, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentStartExecute(r)
}

/*
 * ProviderProjectDevelopmentStart Start provider/development
 * action start
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentStartRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentStart(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentStartRequest {
	return ApiProviderProjectDevelopmentStartRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return Development
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentStartExecute(r ApiProviderProjectDevelopmentStartRequest) (Development, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Development
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentStart")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/actions/start"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentStopRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiProviderProjectDevelopmentStopRequest) XIdempotencyKey(xIdempotencyKey string) ApiProviderProjectDevelopmentStopRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
func (r ApiProviderProjectDevelopmentStopRequest) XDryRun(xDryRun string) ApiProviderProjectDevelopmentStopRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiProviderProjectDevelopmentStopRequest) Execute() (Development, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentStopExecute(r)
}

/*
 * ProviderProjectDevelopmentStop Stop provider/development
 * action stop
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentStopRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentStop(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentStopRequest {
	return ApiProviderProjectDevelopmentStopRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return Development
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentStopExecute(r ApiProviderProjectDevelopmentStopRequest) (Development, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Development
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentStop")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/actions/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentTagCreateRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	tag *Tag
}

func (r ApiProviderProjectDevelopmentTagCreateRequest) Tag(tag Tag) ApiProviderProjectDevelopmentTagCreateRequest {
	r.tag = &tag
	return r
}

func (r ApiProviderProjectDevelopmentTagCreateRequest) Execute() (Tag, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentTagCreateExecute(r)
}

/*
 * ProviderProjectDevelopmentTagCreate Create provider/development.tag
 * Create provider/development.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentTagCreateRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentTagCreate(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentTagCreateRequest {
	return ApiProviderProjectDevelopmentTagCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return Tag
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentTagCreateExecute(r ApiProviderProjectDevelopmentTagCreateRequest) (Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentTagCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.tag == nil {
		return localVarReturnValue, nil, reportError("tag is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tag
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentTagDeleteRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	tagId string
}


func (r ApiProviderProjectDevelopmentTagDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentTagDeleteExecute(r)
}

/*
 * ProviderProjectDevelopmentTagDelete Delete provider/development.tag
 * Delete provider/development.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @param tagId tagId
 * @return ApiProviderProjectDevelopmentTagDeleteRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentTagDelete(ctx _context.Context, projectId string, locationId string, developmentId string, tagId string) ApiProviderProjectDevelopmentTagDeleteRequest {
	return ApiProviderProjectDevelopmentTagDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
		tagId: tagId,
	}
}

/*
 * Execute executes the request
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentTagDeleteExecute(r ApiProviderProjectDevelopmentTagDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentTagDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/tag/{tagId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", _neturl.PathEscape(parameterToString(r.tagId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentTagGetRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	tagId string
}


func (r ApiProviderProjectDevelopmentTagGetRequest) Execute() (Tag, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentTagGetExecute(r)
}

/*
 * ProviderProjectDevelopmentTagGet Get provider/development.tag
 * Get provider/development.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @param tagId tagId
 * @return ApiProviderProjectDevelopmentTagGetRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentTagGet(ctx _context.Context, projectId string, locationId string, developmentId string, tagId string) ApiProviderProjectDevelopmentTagGetRequest {
	return ApiProviderProjectDevelopmentTagGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
		tagId: tagId,
	}
}

/*
 * Execute executes the request
 * @return Tag
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentTagGetExecute(r ApiProviderProjectDevelopmentTagGetRequest) (Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentTagGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/tag/{tagId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", _neturl.PathEscape(parameterToString(r.tagId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentTagListRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
}


func (r ApiProviderProjectDevelopmentTagListRequest) Execute() ([]Tag, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentTagListExecute(r)
}

/*
 * ProviderProjectDevelopmentTagList List provider/development.tag
 * List provider/development.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentTagListRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentTagList(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentTagListRequest {
	return ApiProviderProjectDevelopmentTagListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return []Tag
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentTagListExecute(r ApiProviderProjectDevelopmentTagListRequest) ([]Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentTagList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentTagPutRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	tag *[]Tag
}

func (r ApiProviderProjectDevelopmentTagPutRequest) Tag(tag []Tag) ApiProviderProjectDevelopmentTagPutRequest {
	r.tag = &tag
	return r
}

func (r ApiProviderProjectDevelopmentTagPutRequest) Execute() ([]Tag, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentTagPutExecute(r)
}

/*
 * ProviderProjectDevelopmentTagPut Replace provider/development.tag
 * Replace provider/development.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentTagPutRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentTagPut(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentTagPutRequest {
	return ApiProviderProjectDevelopmentTagPutRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return []Tag
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentTagPutExecute(r ApiProviderProjectDevelopmentTagPutRequest) ([]Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentTagPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.tag == nil {
		return localVarReturnValue, nil, reportError("tag is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tag
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentTransferRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	providerProjectDevelopmentTransfer *ProviderProjectDevelopmentTransfer
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiProviderProjectDevelopmentTransferRequest) ProviderProjectDevelopmentTransfer(providerProjectDevelopmentTransfer ProviderProjectDevelopmentTransfer) ApiProviderProjectDevelopmentTransferRequest {
	r.providerProjectDevelopmentTransfer = &providerProjectDevelopmentTransfer
	return r
}
func (r ApiProviderProjectDevelopmentTransferRequest) XIdempotencyKey(xIdempotencyKey string) ApiProviderProjectDevelopmentTransferRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
func (r ApiProviderProjectDevelopmentTransferRequest) XDryRun(xDryRun string) ApiProviderProjectDevelopmentTransferRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiProviderProjectDevelopmentTransferRequest) Execute() (Development, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentTransferExecute(r)
}

/*
 * ProviderProjectDevelopmentTransfer Transfer provider/development
 * action transfer
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentTransferRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentTransfer(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentTransferRequest {
	return ApiProviderProjectDevelopmentTransferRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return Development
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentTransferExecute(r ApiProviderProjectDevelopmentTransferRequest) (Development, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Development
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentTransfer")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}/actions/transfer"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.providerProjectDevelopmentTransfer == nil {
		return localVarReturnValue, nil, reportError("providerProjectDevelopmentTransfer is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	// body params
	localVarPostBody = r.providerProjectDevelopmentTransfer
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProviderProjectDevelopmentUpdateRequest struct {
	ctx _context.Context
	ApiService *ProviderProjectDevelopmentApiService
	projectId string
	locationId string
	developmentId string
	providerProjectDevelopmentUpdate *ProviderProjectDevelopmentUpdate
}

func (r ApiProviderProjectDevelopmentUpdateRequest) ProviderProjectDevelopmentUpdate(providerProjectDevelopmentUpdate ProviderProjectDevelopmentUpdate) ApiProviderProjectDevelopmentUpdateRequest {
	r.providerProjectDevelopmentUpdate = &providerProjectDevelopmentUpdate
	return r
}

func (r ApiProviderProjectDevelopmentUpdateRequest) Execute() (Development, *_nethttp.Response, error) {
	return r.ApiService.ProviderProjectDevelopmentUpdateExecute(r)
}

/*
 * ProviderProjectDevelopmentUpdate Update provider/development
 * Returns modified development
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project Id
 * @param locationId Location Id
 * @param developmentId Development Id
 * @return ApiProviderProjectDevelopmentUpdateRequest
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentUpdate(ctx _context.Context, projectId string, locationId string, developmentId string) ApiProviderProjectDevelopmentUpdateRequest {
	return ApiProviderProjectDevelopmentUpdateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		developmentId: developmentId,
	}
}

/*
 * Execute executes the request
 * @return Development
 */
func (a *ProviderProjectDevelopmentApiService) ProviderProjectDevelopmentUpdateExecute(r ApiProviderProjectDevelopmentUpdateRequest) (Development, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Development
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProviderProjectDevelopmentApiService.ProviderProjectDevelopmentUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/provider/{locationId}/project/{projectId}/development/{developmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", _neturl.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"developmentId"+"}", _neturl.PathEscape(parameterToString(r.developmentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.providerProjectDevelopmentUpdate == nil {
		return localVarReturnValue, nil, reportError("providerProjectDevelopmentUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.providerProjectDevelopmentUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
