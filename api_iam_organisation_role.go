/*
 * HyperOne
 *
 * HyperOne API
 *
 * API version: 0.1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package h1

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// IamOrganisationRoleApiService IamOrganisationRoleApi service
type IamOrganisationRoleApiService service

type ApiIamOrganisationRoleCreateRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationRoleApiService
	organisationId string
	iamProjectRoleCreate *IamProjectRoleCreate
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiIamOrganisationRoleCreateRequest) IamProjectRoleCreate(iamProjectRoleCreate IamProjectRoleCreate) ApiIamOrganisationRoleCreateRequest {
	r.iamProjectRoleCreate = &iamProjectRoleCreate
	return r
}
func (r ApiIamOrganisationRoleCreateRequest) XIdempotencyKey(xIdempotencyKey string) ApiIamOrganisationRoleCreateRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
func (r ApiIamOrganisationRoleCreateRequest) XDryRun(xDryRun string) ApiIamOrganisationRoleCreateRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiIamOrganisationRoleCreateRequest) Execute() (Role, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationRoleCreateExecute(r)
}

/*
 * IamOrganisationRoleCreate Create iam/role
 * Create role
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @return ApiIamOrganisationRoleCreateRequest
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleCreate(ctx _context.Context, organisationId string) ApiIamOrganisationRoleCreateRequest {
	return ApiIamOrganisationRoleCreateRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

/*
 * Execute executes the request
 * @return Role
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleCreateExecute(r ApiIamOrganisationRoleCreateRequest) (Role, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationRoleApiService.IamOrganisationRoleCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/role"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.iamProjectRoleCreate == nil {
		return localVarReturnValue, nil, reportError("iamProjectRoleCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	// body params
	localVarPostBody = r.iamProjectRoleCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationRoleDeleteRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationRoleApiService
	organisationId string
	roleId string
}


func (r ApiIamOrganisationRoleDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IamOrganisationRoleDeleteExecute(r)
}

/*
 * IamOrganisationRoleDelete Delete iam/role
 * Delete role
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param roleId Role Id
 * @return ApiIamOrganisationRoleDeleteRequest
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleDelete(ctx _context.Context, organisationId string, roleId string) ApiIamOrganisationRoleDeleteRequest {
	return ApiIamOrganisationRoleDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		roleId: roleId,
	}
}

/*
 * Execute executes the request
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleDeleteExecute(r ApiIamOrganisationRoleDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationRoleApiService.IamOrganisationRoleDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/role/{roleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleId"+"}", _neturl.PathEscape(parameterToString(r.roleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIamOrganisationRoleEventGetRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationRoleApiService
	organisationId string
	roleId string
	eventId string
}


func (r ApiIamOrganisationRoleEventGetRequest) Execute() (Event, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationRoleEventGetExecute(r)
}

/*
 * IamOrganisationRoleEventGet Get iam/role.event
 * Get iam/role.event
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param roleId Role Id
 * @param eventId eventId
 * @return ApiIamOrganisationRoleEventGetRequest
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleEventGet(ctx _context.Context, organisationId string, roleId string, eventId string) ApiIamOrganisationRoleEventGetRequest {
	return ApiIamOrganisationRoleEventGetRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		roleId: roleId,
		eventId: eventId,
	}
}

/*
 * Execute executes the request
 * @return Event
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleEventGetExecute(r ApiIamOrganisationRoleEventGetRequest) (Event, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationRoleApiService.IamOrganisationRoleEventGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/role/{roleId}/event/{eventId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleId"+"}", _neturl.PathEscape(parameterToString(r.roleId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", _neturl.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationRoleEventListRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationRoleApiService
	organisationId string
	roleId string
	limit *float32
	skip *float32
}

func (r ApiIamOrganisationRoleEventListRequest) Limit(limit float32) ApiIamOrganisationRoleEventListRequest {
	r.limit = &limit
	return r
}
func (r ApiIamOrganisationRoleEventListRequest) Skip(skip float32) ApiIamOrganisationRoleEventListRequest {
	r.skip = &skip
	return r
}

func (r ApiIamOrganisationRoleEventListRequest) Execute() ([]Event, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationRoleEventListExecute(r)
}

/*
 * IamOrganisationRoleEventList List iam/role.event
 * List iam/role.event
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param roleId Role Id
 * @return ApiIamOrganisationRoleEventListRequest
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleEventList(ctx _context.Context, organisationId string, roleId string) ApiIamOrganisationRoleEventListRequest {
	return ApiIamOrganisationRoleEventListRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		roleId: roleId,
	}
}

/*
 * Execute executes the request
 * @return []Event
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleEventListExecute(r ApiIamOrganisationRoleEventListRequest) ([]Event, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationRoleApiService.IamOrganisationRoleEventList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/role/{roleId}/event"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleId"+"}", _neturl.PathEscape(parameterToString(r.roleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("$limit", parameterToString(*r.limit, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationRoleGetRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationRoleApiService
	organisationId string
	roleId string
}


func (r ApiIamOrganisationRoleGetRequest) Execute() (Role, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationRoleGetExecute(r)
}

/*
 * IamOrganisationRoleGet Get iam/role
 * Returns a single role
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param roleId Role Id
 * @return ApiIamOrganisationRoleGetRequest
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleGet(ctx _context.Context, organisationId string, roleId string) ApiIamOrganisationRoleGetRequest {
	return ApiIamOrganisationRoleGetRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		roleId: roleId,
	}
}

/*
 * Execute executes the request
 * @return Role
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleGetExecute(r ApiIamOrganisationRoleGetRequest) (Role, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationRoleApiService.IamOrganisationRoleGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/role/{roleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleId"+"}", _neturl.PathEscape(parameterToString(r.roleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationRoleListRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationRoleApiService
	organisationId string
	name *string
	tagValue *string
	tagKey *string
}

func (r ApiIamOrganisationRoleListRequest) Name(name string) ApiIamOrganisationRoleListRequest {
	r.name = &name
	return r
}
func (r ApiIamOrganisationRoleListRequest) TagValue(tagValue string) ApiIamOrganisationRoleListRequest {
	r.tagValue = &tagValue
	return r
}
func (r ApiIamOrganisationRoleListRequest) TagKey(tagKey string) ApiIamOrganisationRoleListRequest {
	r.tagKey = &tagKey
	return r
}

func (r ApiIamOrganisationRoleListRequest) Execute() ([]Role, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationRoleListExecute(r)
}

/*
 * IamOrganisationRoleList List iam/role
 * List role
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @return ApiIamOrganisationRoleListRequest
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleList(ctx _context.Context, organisationId string) ApiIamOrganisationRoleListRequest {
	return ApiIamOrganisationRoleListRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
	}
}

/*
 * Execute executes the request
 * @return []Role
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleListExecute(r ApiIamOrganisationRoleListRequest) ([]Role, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationRoleApiService.IamOrganisationRoleList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/role"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.tagValue != nil {
		localVarQueryParams.Add("tag.value", parameterToString(*r.tagValue, ""))
	}
	if r.tagKey != nil {
		localVarQueryParams.Add("tag.key", parameterToString(*r.tagKey, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationRolePermissionCreateRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationRoleApiService
	organisationId string
	roleId string
	iamPermission *IamPermission
}

func (r ApiIamOrganisationRolePermissionCreateRequest) IamPermission(iamPermission IamPermission) ApiIamOrganisationRolePermissionCreateRequest {
	r.iamPermission = &iamPermission
	return r
}

func (r ApiIamOrganisationRolePermissionCreateRequest) Execute() (IamPermission, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationRolePermissionCreateExecute(r)
}

/*
 * IamOrganisationRolePermissionCreate Create iam/role.permission
 * Create iam/role.permission
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param roleId Role Id
 * @return ApiIamOrganisationRolePermissionCreateRequest
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRolePermissionCreate(ctx _context.Context, organisationId string, roleId string) ApiIamOrganisationRolePermissionCreateRequest {
	return ApiIamOrganisationRolePermissionCreateRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		roleId: roleId,
	}
}

/*
 * Execute executes the request
 * @return IamPermission
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRolePermissionCreateExecute(r ApiIamOrganisationRolePermissionCreateRequest) (IamPermission, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IamPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationRoleApiService.IamOrganisationRolePermissionCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/role/{roleId}/permission"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleId"+"}", _neturl.PathEscape(parameterToString(r.roleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.iamPermission == nil {
		return localVarReturnValue, nil, reportError("iamPermission is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iamPermission
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationRolePermissionDeleteRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationRoleApiService
	organisationId string
	roleId string
	permissionId string
}


func (r ApiIamOrganisationRolePermissionDeleteRequest) Execute() (IamPermission, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationRolePermissionDeleteExecute(r)
}

/*
 * IamOrganisationRolePermissionDelete Delete iam/role.permission
 * Delete iam/role.permission
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param roleId Role Id
 * @param permissionId permissionId
 * @return ApiIamOrganisationRolePermissionDeleteRequest
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRolePermissionDelete(ctx _context.Context, organisationId string, roleId string, permissionId string) ApiIamOrganisationRolePermissionDeleteRequest {
	return ApiIamOrganisationRolePermissionDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		roleId: roleId,
		permissionId: permissionId,
	}
}

/*
 * Execute executes the request
 * @return IamPermission
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRolePermissionDeleteExecute(r ApiIamOrganisationRolePermissionDeleteRequest) (IamPermission, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IamPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationRoleApiService.IamOrganisationRolePermissionDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/role/{roleId}/permission/{permissionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleId"+"}", _neturl.PathEscape(parameterToString(r.roleId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"permissionId"+"}", _neturl.PathEscape(parameterToString(r.permissionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationRolePermissionGetRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationRoleApiService
	organisationId string
	roleId string
	permissionId string
}


func (r ApiIamOrganisationRolePermissionGetRequest) Execute() (IamPermission, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationRolePermissionGetExecute(r)
}

/*
 * IamOrganisationRolePermissionGet Get iam/role.permission
 * Get iam/role.permission
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param roleId Role Id
 * @param permissionId permissionId
 * @return ApiIamOrganisationRolePermissionGetRequest
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRolePermissionGet(ctx _context.Context, organisationId string, roleId string, permissionId string) ApiIamOrganisationRolePermissionGetRequest {
	return ApiIamOrganisationRolePermissionGetRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		roleId: roleId,
		permissionId: permissionId,
	}
}

/*
 * Execute executes the request
 * @return IamPermission
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRolePermissionGetExecute(r ApiIamOrganisationRolePermissionGetRequest) (IamPermission, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IamPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationRoleApiService.IamOrganisationRolePermissionGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/role/{roleId}/permission/{permissionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleId"+"}", _neturl.PathEscape(parameterToString(r.roleId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"permissionId"+"}", _neturl.PathEscape(parameterToString(r.permissionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationRolePermissionListRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationRoleApiService
	organisationId string
	roleId string
}


func (r ApiIamOrganisationRolePermissionListRequest) Execute() ([]IamPermission, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationRolePermissionListExecute(r)
}

/*
 * IamOrganisationRolePermissionList List iam/role.permission
 * List iam/role.permission
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param roleId Role Id
 * @return ApiIamOrganisationRolePermissionListRequest
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRolePermissionList(ctx _context.Context, organisationId string, roleId string) ApiIamOrganisationRolePermissionListRequest {
	return ApiIamOrganisationRolePermissionListRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		roleId: roleId,
	}
}

/*
 * Execute executes the request
 * @return []IamPermission
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRolePermissionListExecute(r ApiIamOrganisationRolePermissionListRequest) ([]IamPermission, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []IamPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationRoleApiService.IamOrganisationRolePermissionList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/role/{roleId}/permission"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleId"+"}", _neturl.PathEscape(parameterToString(r.roleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationRolePermissionPutRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationRoleApiService
	organisationId string
	roleId string
	iamPermission *[]IamPermission
}

func (r ApiIamOrganisationRolePermissionPutRequest) IamPermission(iamPermission []IamPermission) ApiIamOrganisationRolePermissionPutRequest {
	r.iamPermission = &iamPermission
	return r
}

func (r ApiIamOrganisationRolePermissionPutRequest) Execute() ([]IamPermission, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationRolePermissionPutExecute(r)
}

/*
 * IamOrganisationRolePermissionPut Replace iam/role.permission
 * Replace iam/role.permission
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param roleId Role Id
 * @return ApiIamOrganisationRolePermissionPutRequest
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRolePermissionPut(ctx _context.Context, organisationId string, roleId string) ApiIamOrganisationRolePermissionPutRequest {
	return ApiIamOrganisationRolePermissionPutRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		roleId: roleId,
	}
}

/*
 * Execute executes the request
 * @return []IamPermission
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRolePermissionPutExecute(r ApiIamOrganisationRolePermissionPutRequest) ([]IamPermission, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []IamPermission
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationRoleApiService.IamOrganisationRolePermissionPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/role/{roleId}/permission"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleId"+"}", _neturl.PathEscape(parameterToString(r.roleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.iamPermission == nil {
		return localVarReturnValue, nil, reportError("iamPermission is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iamPermission
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationRoleServiceGetRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationRoleApiService
	organisationId string
	roleId string
	serviceId string
}


func (r ApiIamOrganisationRoleServiceGetRequest) Execute() (ResourceService, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationRoleServiceGetExecute(r)
}

/*
 * IamOrganisationRoleServiceGet Get iam/role.service
 * Get iam/role.service
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param roleId Role Id
 * @param serviceId serviceId
 * @return ApiIamOrganisationRoleServiceGetRequest
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleServiceGet(ctx _context.Context, organisationId string, roleId string, serviceId string) ApiIamOrganisationRoleServiceGetRequest {
	return ApiIamOrganisationRoleServiceGetRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		roleId: roleId,
		serviceId: serviceId,
	}
}

/*
 * Execute executes the request
 * @return ResourceService
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleServiceGetExecute(r ApiIamOrganisationRoleServiceGetRequest) (ResourceService, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResourceService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationRoleApiService.IamOrganisationRoleServiceGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/role/{roleId}/service/{serviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleId"+"}", _neturl.PathEscape(parameterToString(r.roleId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serviceId"+"}", _neturl.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationRoleServiceListRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationRoleApiService
	organisationId string
	roleId string
}


func (r ApiIamOrganisationRoleServiceListRequest) Execute() ([]ResourceService, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationRoleServiceListExecute(r)
}

/*
 * IamOrganisationRoleServiceList List iam/role.service
 * List iam/role.service
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param roleId Role Id
 * @return ApiIamOrganisationRoleServiceListRequest
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleServiceList(ctx _context.Context, organisationId string, roleId string) ApiIamOrganisationRoleServiceListRequest {
	return ApiIamOrganisationRoleServiceListRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		roleId: roleId,
	}
}

/*
 * Execute executes the request
 * @return []ResourceService
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleServiceListExecute(r ApiIamOrganisationRoleServiceListRequest) ([]ResourceService, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ResourceService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationRoleApiService.IamOrganisationRoleServiceList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/role/{roleId}/service"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleId"+"}", _neturl.PathEscape(parameterToString(r.roleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationRoleTagCreateRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationRoleApiService
	organisationId string
	roleId string
	tag *Tag
}

func (r ApiIamOrganisationRoleTagCreateRequest) Tag(tag Tag) ApiIamOrganisationRoleTagCreateRequest {
	r.tag = &tag
	return r
}

func (r ApiIamOrganisationRoleTagCreateRequest) Execute() (Tag, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationRoleTagCreateExecute(r)
}

/*
 * IamOrganisationRoleTagCreate Create iam/role.tag
 * Create iam/role.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param roleId Role Id
 * @return ApiIamOrganisationRoleTagCreateRequest
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleTagCreate(ctx _context.Context, organisationId string, roleId string) ApiIamOrganisationRoleTagCreateRequest {
	return ApiIamOrganisationRoleTagCreateRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		roleId: roleId,
	}
}

/*
 * Execute executes the request
 * @return Tag
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleTagCreateExecute(r ApiIamOrganisationRoleTagCreateRequest) (Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationRoleApiService.IamOrganisationRoleTagCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/role/{roleId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleId"+"}", _neturl.PathEscape(parameterToString(r.roleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.tag == nil {
		return localVarReturnValue, nil, reportError("tag is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tag
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationRoleTagDeleteRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationRoleApiService
	organisationId string
	roleId string
	tagId string
}


func (r ApiIamOrganisationRoleTagDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.IamOrganisationRoleTagDeleteExecute(r)
}

/*
 * IamOrganisationRoleTagDelete Delete iam/role.tag
 * Delete iam/role.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param roleId Role Id
 * @param tagId tagId
 * @return ApiIamOrganisationRoleTagDeleteRequest
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleTagDelete(ctx _context.Context, organisationId string, roleId string, tagId string) ApiIamOrganisationRoleTagDeleteRequest {
	return ApiIamOrganisationRoleTagDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		roleId: roleId,
		tagId: tagId,
	}
}

/*
 * Execute executes the request
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleTagDeleteExecute(r ApiIamOrganisationRoleTagDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationRoleApiService.IamOrganisationRoleTagDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/role/{roleId}/tag/{tagId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleId"+"}", _neturl.PathEscape(parameterToString(r.roleId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", _neturl.PathEscape(parameterToString(r.tagId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIamOrganisationRoleTagGetRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationRoleApiService
	organisationId string
	roleId string
	tagId string
}


func (r ApiIamOrganisationRoleTagGetRequest) Execute() (Tag, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationRoleTagGetExecute(r)
}

/*
 * IamOrganisationRoleTagGet Get iam/role.tag
 * Get iam/role.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param roleId Role Id
 * @param tagId tagId
 * @return ApiIamOrganisationRoleTagGetRequest
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleTagGet(ctx _context.Context, organisationId string, roleId string, tagId string) ApiIamOrganisationRoleTagGetRequest {
	return ApiIamOrganisationRoleTagGetRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		roleId: roleId,
		tagId: tagId,
	}
}

/*
 * Execute executes the request
 * @return Tag
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleTagGetExecute(r ApiIamOrganisationRoleTagGetRequest) (Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationRoleApiService.IamOrganisationRoleTagGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/role/{roleId}/tag/{tagId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleId"+"}", _neturl.PathEscape(parameterToString(r.roleId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", _neturl.PathEscape(parameterToString(r.tagId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationRoleTagListRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationRoleApiService
	organisationId string
	roleId string
}


func (r ApiIamOrganisationRoleTagListRequest) Execute() ([]Tag, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationRoleTagListExecute(r)
}

/*
 * IamOrganisationRoleTagList List iam/role.tag
 * List iam/role.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param roleId Role Id
 * @return ApiIamOrganisationRoleTagListRequest
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleTagList(ctx _context.Context, organisationId string, roleId string) ApiIamOrganisationRoleTagListRequest {
	return ApiIamOrganisationRoleTagListRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		roleId: roleId,
	}
}

/*
 * Execute executes the request
 * @return []Tag
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleTagListExecute(r ApiIamOrganisationRoleTagListRequest) ([]Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationRoleApiService.IamOrganisationRoleTagList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/role/{roleId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleId"+"}", _neturl.PathEscape(parameterToString(r.roleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationRoleTagPutRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationRoleApiService
	organisationId string
	roleId string
	tag *[]Tag
}

func (r ApiIamOrganisationRoleTagPutRequest) Tag(tag []Tag) ApiIamOrganisationRoleTagPutRequest {
	r.tag = &tag
	return r
}

func (r ApiIamOrganisationRoleTagPutRequest) Execute() ([]Tag, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationRoleTagPutExecute(r)
}

/*
 * IamOrganisationRoleTagPut Replace iam/role.tag
 * Replace iam/role.tag
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param roleId Role Id
 * @return ApiIamOrganisationRoleTagPutRequest
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleTagPut(ctx _context.Context, organisationId string, roleId string) ApiIamOrganisationRoleTagPutRequest {
	return ApiIamOrganisationRoleTagPutRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		roleId: roleId,
	}
}

/*
 * Execute executes the request
 * @return []Tag
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleTagPutExecute(r ApiIamOrganisationRoleTagPutRequest) ([]Tag, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationRoleApiService.IamOrganisationRoleTagPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/role/{roleId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleId"+"}", _neturl.PathEscape(parameterToString(r.roleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.tag == nil {
		return localVarReturnValue, nil, reportError("tag is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tag
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIamOrganisationRoleUpdateRequest struct {
	ctx _context.Context
	ApiService *IamOrganisationRoleApiService
	organisationId string
	roleId string
	iamProjectRoleUpdate *IamProjectRoleUpdate
}

func (r ApiIamOrganisationRoleUpdateRequest) IamProjectRoleUpdate(iamProjectRoleUpdate IamProjectRoleUpdate) ApiIamOrganisationRoleUpdateRequest {
	r.iamProjectRoleUpdate = &iamProjectRoleUpdate
	return r
}

func (r ApiIamOrganisationRoleUpdateRequest) Execute() (Role, *_nethttp.Response, error) {
	return r.ApiService.IamOrganisationRoleUpdateExecute(r)
}

/*
 * IamOrganisationRoleUpdate Update iam/role
 * Returns modified role
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param organisationId Organisation Id
 * @param roleId Role Id
 * @return ApiIamOrganisationRoleUpdateRequest
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleUpdate(ctx _context.Context, organisationId string, roleId string) ApiIamOrganisationRoleUpdateRequest {
	return ApiIamOrganisationRoleUpdateRequest{
		ApiService: a,
		ctx: ctx,
		organisationId: organisationId,
		roleId: roleId,
	}
}

/*
 * Execute executes the request
 * @return Role
 */
func (a *IamOrganisationRoleApiService) IamOrganisationRoleUpdateExecute(r ApiIamOrganisationRoleUpdateRequest) (Role, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IamOrganisationRoleApiService.IamOrganisationRoleUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/organisation/{organisationId}/role/{roleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organisationId"+"}", _neturl.PathEscape(parameterToString(r.organisationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleId"+"}", _neturl.PathEscape(parameterToString(r.roleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.iamProjectRoleUpdate == nil {
		return localVarReturnValue, nil, reportError("iamProjectRoleUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iamProjectRoleUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
