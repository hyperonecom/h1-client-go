/*
HyperOne

HyperOne API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

// RecoveryProjectPlanApiService RecoveryProjectPlanApi service
type RecoveryProjectPlanApiService service

type ApiRecoveryProjectPlanCreateRequest struct {
	ctx context.Context
	ApiService *RecoveryProjectPlanApiService
	projectId string
	locationId string
	recoveryProjectPlanCreate *RecoveryProjectPlanCreate
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiRecoveryProjectPlanCreateRequest) RecoveryProjectPlanCreate(recoveryProjectPlanCreate RecoveryProjectPlanCreate) ApiRecoveryProjectPlanCreateRequest {
	r.recoveryProjectPlanCreate = &recoveryProjectPlanCreate
	return r
}
// Idempotency key
func (r ApiRecoveryProjectPlanCreateRequest) XIdempotencyKey(xIdempotencyKey string) ApiRecoveryProjectPlanCreateRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
// Dry run
func (r ApiRecoveryProjectPlanCreateRequest) XDryRun(xDryRun string) ApiRecoveryProjectPlanCreateRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiRecoveryProjectPlanCreateRequest) Execute() (*Plan, *http.Response, error) {
	return r.ApiService.RecoveryProjectPlanCreateExecute(r)
}

/*
RecoveryProjectPlanCreate Create recovery/plan

Create plan

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @return ApiRecoveryProjectPlanCreateRequest
*/
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanCreate(ctx context.Context, projectId string, locationId string) ApiRecoveryProjectPlanCreateRequest {
	return ApiRecoveryProjectPlanCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
	}
}

// Execute executes the request
//  @return Plan
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanCreateExecute(r ApiRecoveryProjectPlanCreateRequest) (*Plan, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Plan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryProjectPlanApiService.RecoveryProjectPlanCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/recovery/{locationId}/project/{projectId}/plan"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.recoveryProjectPlanCreate == nil {
		return localVarReturnValue, nil, reportError("recoveryProjectPlanCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	// body params
	localVarPostBody = r.recoveryProjectPlanCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecoveryProjectPlanDeleteRequest struct {
	ctx context.Context
	ApiService *RecoveryProjectPlanApiService
	projectId string
	locationId string
	planId string
}


func (r ApiRecoveryProjectPlanDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.RecoveryProjectPlanDeleteExecute(r)
}

/*
RecoveryProjectPlanDelete Delete recovery/plan

Delete plan

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param planId Plan Id
 @return ApiRecoveryProjectPlanDeleteRequest
*/
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanDelete(ctx context.Context, projectId string, locationId string, planId string) ApiRecoveryProjectPlanDeleteRequest {
	return ApiRecoveryProjectPlanDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		planId: planId,
	}
}

// Execute executes the request
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanDeleteExecute(r ApiRecoveryProjectPlanDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryProjectPlanApiService.RecoveryProjectPlanDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/recovery/{locationId}/project/{projectId}/plan/{planId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"planId"+"}", url.PathEscape(parameterToString(r.planId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRecoveryProjectPlanEventGetRequest struct {
	ctx context.Context
	ApiService *RecoveryProjectPlanApiService
	projectId string
	locationId string
	planId string
	eventId string
}


func (r ApiRecoveryProjectPlanEventGetRequest) Execute() (*Event, *http.Response, error) {
	return r.ApiService.RecoveryProjectPlanEventGetExecute(r)
}

/*
RecoveryProjectPlanEventGet Get recovery/plan.event

Get recovery/plan.event

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param planId Plan Id
 @param eventId eventId
 @return ApiRecoveryProjectPlanEventGetRequest
*/
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanEventGet(ctx context.Context, projectId string, locationId string, planId string, eventId string) ApiRecoveryProjectPlanEventGetRequest {
	return ApiRecoveryProjectPlanEventGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		planId: planId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return Event
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanEventGetExecute(r ApiRecoveryProjectPlanEventGetRequest) (*Event, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryProjectPlanApiService.RecoveryProjectPlanEventGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/recovery/{locationId}/project/{projectId}/plan/{planId}/event/{eventId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"planId"+"}", url.PathEscape(parameterToString(r.planId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", url.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecoveryProjectPlanEventListRequest struct {
	ctx context.Context
	ApiService *RecoveryProjectPlanApiService
	projectId string
	locationId string
	planId string
	limit *float32
	skip *float32
}

// $limit
func (r ApiRecoveryProjectPlanEventListRequest) Limit(limit float32) ApiRecoveryProjectPlanEventListRequest {
	r.limit = &limit
	return r
}
// $skip
func (r ApiRecoveryProjectPlanEventListRequest) Skip(skip float32) ApiRecoveryProjectPlanEventListRequest {
	r.skip = &skip
	return r
}

func (r ApiRecoveryProjectPlanEventListRequest) Execute() ([]Event, *http.Response, error) {
	return r.ApiService.RecoveryProjectPlanEventListExecute(r)
}

/*
RecoveryProjectPlanEventList List recovery/plan.event

List recovery/plan.event

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param planId Plan Id
 @return ApiRecoveryProjectPlanEventListRequest
*/
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanEventList(ctx context.Context, projectId string, locationId string, planId string) ApiRecoveryProjectPlanEventListRequest {
	return ApiRecoveryProjectPlanEventListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		planId: planId,
	}
}

// Execute executes the request
//  @return []Event
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanEventListExecute(r ApiRecoveryProjectPlanEventListRequest) ([]Event, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryProjectPlanApiService.RecoveryProjectPlanEventList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/recovery/{locationId}/project/{projectId}/plan/{planId}/event"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"planId"+"}", url.PathEscape(parameterToString(r.planId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("$limit", parameterToString(*r.limit, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecoveryProjectPlanGetRequest struct {
	ctx context.Context
	ApiService *RecoveryProjectPlanApiService
	projectId string
	locationId string
	planId string
}


func (r ApiRecoveryProjectPlanGetRequest) Execute() (*Plan, *http.Response, error) {
	return r.ApiService.RecoveryProjectPlanGetExecute(r)
}

/*
RecoveryProjectPlanGet Get recovery/plan

Returns a single plan

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param planId Plan Id
 @return ApiRecoveryProjectPlanGetRequest
*/
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanGet(ctx context.Context, projectId string, locationId string, planId string) ApiRecoveryProjectPlanGetRequest {
	return ApiRecoveryProjectPlanGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		planId: planId,
	}
}

// Execute executes the request
//  @return Plan
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanGetExecute(r ApiRecoveryProjectPlanGetRequest) (*Plan, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Plan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryProjectPlanApiService.RecoveryProjectPlanGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/recovery/{locationId}/project/{projectId}/plan/{planId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"planId"+"}", url.PathEscape(parameterToString(r.planId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecoveryProjectPlanListRequest struct {
	ctx context.Context
	ApiService *RecoveryProjectPlanApiService
	projectId string
	locationId string
	name *string
	tagValue *string
	tagKey *string
}

// Filter by name
func (r ApiRecoveryProjectPlanListRequest) Name(name string) ApiRecoveryProjectPlanListRequest {
	r.name = &name
	return r
}
// Filter by tag.value
func (r ApiRecoveryProjectPlanListRequest) TagValue(tagValue string) ApiRecoveryProjectPlanListRequest {
	r.tagValue = &tagValue
	return r
}
// Filter by tag.key
func (r ApiRecoveryProjectPlanListRequest) TagKey(tagKey string) ApiRecoveryProjectPlanListRequest {
	r.tagKey = &tagKey
	return r
}

func (r ApiRecoveryProjectPlanListRequest) Execute() ([]Plan, *http.Response, error) {
	return r.ApiService.RecoveryProjectPlanListExecute(r)
}

/*
RecoveryProjectPlanList List recovery/plan

List plan

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @return ApiRecoveryProjectPlanListRequest
*/
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanList(ctx context.Context, projectId string, locationId string) ApiRecoveryProjectPlanListRequest {
	return ApiRecoveryProjectPlanListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
	}
}

// Execute executes the request
//  @return []Plan
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanListExecute(r ApiRecoveryProjectPlanListRequest) ([]Plan, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Plan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryProjectPlanApiService.RecoveryProjectPlanList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/recovery/{locationId}/project/{projectId}/plan"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.tagValue != nil {
		localVarQueryParams.Add("tag.value", parameterToString(*r.tagValue, ""))
	}
	if r.tagKey != nil {
		localVarQueryParams.Add("tag.key", parameterToString(*r.tagKey, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecoveryProjectPlanServiceGetRequest struct {
	ctx context.Context
	ApiService *RecoveryProjectPlanApiService
	projectId string
	locationId string
	planId string
	serviceId string
}


func (r ApiRecoveryProjectPlanServiceGetRequest) Execute() (*ResourceService, *http.Response, error) {
	return r.ApiService.RecoveryProjectPlanServiceGetExecute(r)
}

/*
RecoveryProjectPlanServiceGet Get recovery/plan.service

Get recovery/plan.service

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param planId Plan Id
 @param serviceId serviceId
 @return ApiRecoveryProjectPlanServiceGetRequest
*/
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanServiceGet(ctx context.Context, projectId string, locationId string, planId string, serviceId string) ApiRecoveryProjectPlanServiceGetRequest {
	return ApiRecoveryProjectPlanServiceGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		planId: planId,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return ResourceService
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanServiceGetExecute(r ApiRecoveryProjectPlanServiceGetRequest) (*ResourceService, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourceService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryProjectPlanApiService.RecoveryProjectPlanServiceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/recovery/{locationId}/project/{projectId}/plan/{planId}/service/{serviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"planId"+"}", url.PathEscape(parameterToString(r.planId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serviceId"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecoveryProjectPlanServiceListRequest struct {
	ctx context.Context
	ApiService *RecoveryProjectPlanApiService
	projectId string
	locationId string
	planId string
}


func (r ApiRecoveryProjectPlanServiceListRequest) Execute() ([]ResourceService, *http.Response, error) {
	return r.ApiService.RecoveryProjectPlanServiceListExecute(r)
}

/*
RecoveryProjectPlanServiceList List recovery/plan.service

List recovery/plan.service

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param planId Plan Id
 @return ApiRecoveryProjectPlanServiceListRequest
*/
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanServiceList(ctx context.Context, projectId string, locationId string, planId string) ApiRecoveryProjectPlanServiceListRequest {
	return ApiRecoveryProjectPlanServiceListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		planId: planId,
	}
}

// Execute executes the request
//  @return []ResourceService
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanServiceListExecute(r ApiRecoveryProjectPlanServiceListRequest) ([]ResourceService, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ResourceService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryProjectPlanApiService.RecoveryProjectPlanServiceList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/recovery/{locationId}/project/{projectId}/plan/{planId}/service"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"planId"+"}", url.PathEscape(parameterToString(r.planId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecoveryProjectPlanTagCreateRequest struct {
	ctx context.Context
	ApiService *RecoveryProjectPlanApiService
	projectId string
	locationId string
	planId string
	tag *Tag
}

func (r ApiRecoveryProjectPlanTagCreateRequest) Tag(tag Tag) ApiRecoveryProjectPlanTagCreateRequest {
	r.tag = &tag
	return r
}

func (r ApiRecoveryProjectPlanTagCreateRequest) Execute() (*Tag, *http.Response, error) {
	return r.ApiService.RecoveryProjectPlanTagCreateExecute(r)
}

/*
RecoveryProjectPlanTagCreate Create recovery/plan.tag

Create recovery/plan.tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param planId Plan Id
 @return ApiRecoveryProjectPlanTagCreateRequest
*/
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanTagCreate(ctx context.Context, projectId string, locationId string, planId string) ApiRecoveryProjectPlanTagCreateRequest {
	return ApiRecoveryProjectPlanTagCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		planId: planId,
	}
}

// Execute executes the request
//  @return Tag
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanTagCreateExecute(r ApiRecoveryProjectPlanTagCreateRequest) (*Tag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryProjectPlanApiService.RecoveryProjectPlanTagCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/recovery/{locationId}/project/{projectId}/plan/{planId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"planId"+"}", url.PathEscape(parameterToString(r.planId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tag == nil {
		return localVarReturnValue, nil, reportError("tag is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tag
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecoveryProjectPlanTagDeleteRequest struct {
	ctx context.Context
	ApiService *RecoveryProjectPlanApiService
	projectId string
	locationId string
	planId string
	tagId string
}


func (r ApiRecoveryProjectPlanTagDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.RecoveryProjectPlanTagDeleteExecute(r)
}

/*
RecoveryProjectPlanTagDelete Delete recovery/plan.tag

Delete recovery/plan.tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param planId Plan Id
 @param tagId tagId
 @return ApiRecoveryProjectPlanTagDeleteRequest
*/
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanTagDelete(ctx context.Context, projectId string, locationId string, planId string, tagId string) ApiRecoveryProjectPlanTagDeleteRequest {
	return ApiRecoveryProjectPlanTagDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		planId: planId,
		tagId: tagId,
	}
}

// Execute executes the request
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanTagDeleteExecute(r ApiRecoveryProjectPlanTagDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryProjectPlanApiService.RecoveryProjectPlanTagDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/recovery/{locationId}/project/{projectId}/plan/{planId}/tag/{tagId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"planId"+"}", url.PathEscape(parameterToString(r.planId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", url.PathEscape(parameterToString(r.tagId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRecoveryProjectPlanTagGetRequest struct {
	ctx context.Context
	ApiService *RecoveryProjectPlanApiService
	projectId string
	locationId string
	planId string
	tagId string
}


func (r ApiRecoveryProjectPlanTagGetRequest) Execute() (*Tag, *http.Response, error) {
	return r.ApiService.RecoveryProjectPlanTagGetExecute(r)
}

/*
RecoveryProjectPlanTagGet Get recovery/plan.tag

Get recovery/plan.tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param planId Plan Id
 @param tagId tagId
 @return ApiRecoveryProjectPlanTagGetRequest
*/
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanTagGet(ctx context.Context, projectId string, locationId string, planId string, tagId string) ApiRecoveryProjectPlanTagGetRequest {
	return ApiRecoveryProjectPlanTagGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		planId: planId,
		tagId: tagId,
	}
}

// Execute executes the request
//  @return Tag
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanTagGetExecute(r ApiRecoveryProjectPlanTagGetRequest) (*Tag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryProjectPlanApiService.RecoveryProjectPlanTagGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/recovery/{locationId}/project/{projectId}/plan/{planId}/tag/{tagId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"planId"+"}", url.PathEscape(parameterToString(r.planId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", url.PathEscape(parameterToString(r.tagId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecoveryProjectPlanTagListRequest struct {
	ctx context.Context
	ApiService *RecoveryProjectPlanApiService
	projectId string
	locationId string
	planId string
}


func (r ApiRecoveryProjectPlanTagListRequest) Execute() ([]Tag, *http.Response, error) {
	return r.ApiService.RecoveryProjectPlanTagListExecute(r)
}

/*
RecoveryProjectPlanTagList List recovery/plan.tag

List recovery/plan.tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param planId Plan Id
 @return ApiRecoveryProjectPlanTagListRequest
*/
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanTagList(ctx context.Context, projectId string, locationId string, planId string) ApiRecoveryProjectPlanTagListRequest {
	return ApiRecoveryProjectPlanTagListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		planId: planId,
	}
}

// Execute executes the request
//  @return []Tag
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanTagListExecute(r ApiRecoveryProjectPlanTagListRequest) ([]Tag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryProjectPlanApiService.RecoveryProjectPlanTagList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/recovery/{locationId}/project/{projectId}/plan/{planId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"planId"+"}", url.PathEscape(parameterToString(r.planId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecoveryProjectPlanTagPutRequest struct {
	ctx context.Context
	ApiService *RecoveryProjectPlanApiService
	projectId string
	locationId string
	planId string
	tag *[]Tag
}

func (r ApiRecoveryProjectPlanTagPutRequest) Tag(tag []Tag) ApiRecoveryProjectPlanTagPutRequest {
	r.tag = &tag
	return r
}

func (r ApiRecoveryProjectPlanTagPutRequest) Execute() ([]Tag, *http.Response, error) {
	return r.ApiService.RecoveryProjectPlanTagPutExecute(r)
}

/*
RecoveryProjectPlanTagPut Replace recovery/plan.tag

Replace recovery/plan.tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param planId Plan Id
 @return ApiRecoveryProjectPlanTagPutRequest
*/
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanTagPut(ctx context.Context, projectId string, locationId string, planId string) ApiRecoveryProjectPlanTagPutRequest {
	return ApiRecoveryProjectPlanTagPutRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		planId: planId,
	}
}

// Execute executes the request
//  @return []Tag
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanTagPutExecute(r ApiRecoveryProjectPlanTagPutRequest) ([]Tag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryProjectPlanApiService.RecoveryProjectPlanTagPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/recovery/{locationId}/project/{projectId}/plan/{planId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"planId"+"}", url.PathEscape(parameterToString(r.planId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tag == nil {
		return localVarReturnValue, nil, reportError("tag is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tag
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecoveryProjectPlanUpdateRequest struct {
	ctx context.Context
	ApiService *RecoveryProjectPlanApiService
	projectId string
	locationId string
	planId string
	recoveryProjectPlanUpdate *RecoveryProjectPlanUpdate
}

func (r ApiRecoveryProjectPlanUpdateRequest) RecoveryProjectPlanUpdate(recoveryProjectPlanUpdate RecoveryProjectPlanUpdate) ApiRecoveryProjectPlanUpdateRequest {
	r.recoveryProjectPlanUpdate = &recoveryProjectPlanUpdate
	return r
}

func (r ApiRecoveryProjectPlanUpdateRequest) Execute() (*Plan, *http.Response, error) {
	return r.ApiService.RecoveryProjectPlanUpdateExecute(r)
}

/*
RecoveryProjectPlanUpdate Update recovery/plan

Returns modified plan

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param planId Plan Id
 @return ApiRecoveryProjectPlanUpdateRequest
*/
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanUpdate(ctx context.Context, projectId string, locationId string, planId string) ApiRecoveryProjectPlanUpdateRequest {
	return ApiRecoveryProjectPlanUpdateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		planId: planId,
	}
}

// Execute executes the request
//  @return Plan
func (a *RecoveryProjectPlanApiService) RecoveryProjectPlanUpdateExecute(r ApiRecoveryProjectPlanUpdateRequest) (*Plan, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Plan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryProjectPlanApiService.RecoveryProjectPlanUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/recovery/{locationId}/project/{projectId}/plan/{planId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"planId"+"}", url.PathEscape(parameterToString(r.planId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.recoveryProjectPlanUpdate == nil {
		return localVarReturnValue, nil, reportError("recoveryProjectPlanUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.recoveryProjectPlanUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
