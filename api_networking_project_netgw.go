/*
HyperOne

HyperOne API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

// NetworkingProjectNetgwApiService NetworkingProjectNetgwApi service
type NetworkingProjectNetgwApiService service

type ApiNetworkingProjectNetgwAttachRequest struct {
	ctx context.Context
	ApiService *NetworkingProjectNetgwApiService
	projectId string
	locationId string
	netgwId string
	networkingProjectNetgwAttach *NetworkingProjectNetgwAttach
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiNetworkingProjectNetgwAttachRequest) NetworkingProjectNetgwAttach(networkingProjectNetgwAttach NetworkingProjectNetgwAttach) ApiNetworkingProjectNetgwAttachRequest {
	r.networkingProjectNetgwAttach = &networkingProjectNetgwAttach
	return r
}
// Idempotency key
func (r ApiNetworkingProjectNetgwAttachRequest) XIdempotencyKey(xIdempotencyKey string) ApiNetworkingProjectNetgwAttachRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
// Dry run
func (r ApiNetworkingProjectNetgwAttachRequest) XDryRun(xDryRun string) ApiNetworkingProjectNetgwAttachRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiNetworkingProjectNetgwAttachRequest) Execute() (*Netgw, *http.Response, error) {
	return r.ApiService.NetworkingProjectNetgwAttachExecute(r)
}

/*
NetworkingProjectNetgwAttach Attach networking/netgw

action attach

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param netgwId Netgw Id
 @return ApiNetworkingProjectNetgwAttachRequest
*/
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwAttach(ctx context.Context, projectId string, locationId string, netgwId string) ApiNetworkingProjectNetgwAttachRequest {
	return ApiNetworkingProjectNetgwAttachRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netgwId: netgwId,
	}
}

// Execute executes the request
//  @return Netgw
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwAttachExecute(r ApiNetworkingProjectNetgwAttachRequest) (*Netgw, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Netgw
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetgwApiService.NetworkingProjectNetgwAttach")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netgw/{netgwId}/actions/attach"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netgwId"+"}", url.PathEscape(parameterToString(r.netgwId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.networkingProjectNetgwAttach == nil {
		return localVarReturnValue, nil, reportError("networkingProjectNetgwAttach is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	// body params
	localVarPostBody = r.networkingProjectNetgwAttach
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetgwCreateRequest struct {
	ctx context.Context
	ApiService *NetworkingProjectNetgwApiService
	projectId string
	locationId string
	networkingProjectNetgwCreate *NetworkingProjectNetgwCreate
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiNetworkingProjectNetgwCreateRequest) NetworkingProjectNetgwCreate(networkingProjectNetgwCreate NetworkingProjectNetgwCreate) ApiNetworkingProjectNetgwCreateRequest {
	r.networkingProjectNetgwCreate = &networkingProjectNetgwCreate
	return r
}
// Idempotency key
func (r ApiNetworkingProjectNetgwCreateRequest) XIdempotencyKey(xIdempotencyKey string) ApiNetworkingProjectNetgwCreateRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
// Dry run
func (r ApiNetworkingProjectNetgwCreateRequest) XDryRun(xDryRun string) ApiNetworkingProjectNetgwCreateRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiNetworkingProjectNetgwCreateRequest) Execute() (*Netgw, *http.Response, error) {
	return r.ApiService.NetworkingProjectNetgwCreateExecute(r)
}

/*
NetworkingProjectNetgwCreate Create networking/netgw

Create netgw

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @return ApiNetworkingProjectNetgwCreateRequest
*/
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwCreate(ctx context.Context, projectId string, locationId string) ApiNetworkingProjectNetgwCreateRequest {
	return ApiNetworkingProjectNetgwCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
	}
}

// Execute executes the request
//  @return Netgw
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwCreateExecute(r ApiNetworkingProjectNetgwCreateRequest) (*Netgw, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Netgw
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetgwApiService.NetworkingProjectNetgwCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netgw"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.networkingProjectNetgwCreate == nil {
		return localVarReturnValue, nil, reportError("networkingProjectNetgwCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	// body params
	localVarPostBody = r.networkingProjectNetgwCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetgwDeleteRequest struct {
	ctx context.Context
	ApiService *NetworkingProjectNetgwApiService
	projectId string
	locationId string
	netgwId string
}


func (r ApiNetworkingProjectNetgwDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.NetworkingProjectNetgwDeleteExecute(r)
}

/*
NetworkingProjectNetgwDelete Delete networking/netgw

Delete netgw

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param netgwId Netgw Id
 @return ApiNetworkingProjectNetgwDeleteRequest
*/
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwDelete(ctx context.Context, projectId string, locationId string, netgwId string) ApiNetworkingProjectNetgwDeleteRequest {
	return ApiNetworkingProjectNetgwDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netgwId: netgwId,
	}
}

// Execute executes the request
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwDeleteExecute(r ApiNetworkingProjectNetgwDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetgwApiService.NetworkingProjectNetgwDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netgw/{netgwId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netgwId"+"}", url.PathEscape(parameterToString(r.netgwId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetgwDetachRequest struct {
	ctx context.Context
	ApiService *NetworkingProjectNetgwApiService
	projectId string
	locationId string
	netgwId string
	xIdempotencyKey *string
	xDryRun *string
}

// Idempotency key
func (r ApiNetworkingProjectNetgwDetachRequest) XIdempotencyKey(xIdempotencyKey string) ApiNetworkingProjectNetgwDetachRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
// Dry run
func (r ApiNetworkingProjectNetgwDetachRequest) XDryRun(xDryRun string) ApiNetworkingProjectNetgwDetachRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiNetworkingProjectNetgwDetachRequest) Execute() (*Netgw, *http.Response, error) {
	return r.ApiService.NetworkingProjectNetgwDetachExecute(r)
}

/*
NetworkingProjectNetgwDetach Detach networking/netgw

action detach

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param netgwId Netgw Id
 @return ApiNetworkingProjectNetgwDetachRequest
*/
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwDetach(ctx context.Context, projectId string, locationId string, netgwId string) ApiNetworkingProjectNetgwDetachRequest {
	return ApiNetworkingProjectNetgwDetachRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netgwId: netgwId,
	}
}

// Execute executes the request
//  @return Netgw
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwDetachExecute(r ApiNetworkingProjectNetgwDetachRequest) (*Netgw, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Netgw
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetgwApiService.NetworkingProjectNetgwDetach")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netgw/{netgwId}/actions/detach"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netgwId"+"}", url.PathEscape(parameterToString(r.netgwId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetgwEventGetRequest struct {
	ctx context.Context
	ApiService *NetworkingProjectNetgwApiService
	projectId string
	locationId string
	netgwId string
	eventId string
}


func (r ApiNetworkingProjectNetgwEventGetRequest) Execute() (*Event, *http.Response, error) {
	return r.ApiService.NetworkingProjectNetgwEventGetExecute(r)
}

/*
NetworkingProjectNetgwEventGet Get networking/netgw.event

Get networking/netgw.event

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param netgwId Netgw Id
 @param eventId eventId
 @return ApiNetworkingProjectNetgwEventGetRequest
*/
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwEventGet(ctx context.Context, projectId string, locationId string, netgwId string, eventId string) ApiNetworkingProjectNetgwEventGetRequest {
	return ApiNetworkingProjectNetgwEventGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netgwId: netgwId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return Event
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwEventGetExecute(r ApiNetworkingProjectNetgwEventGetRequest) (*Event, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetgwApiService.NetworkingProjectNetgwEventGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netgw/{netgwId}/event/{eventId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netgwId"+"}", url.PathEscape(parameterToString(r.netgwId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", url.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetgwEventListRequest struct {
	ctx context.Context
	ApiService *NetworkingProjectNetgwApiService
	projectId string
	locationId string
	netgwId string
	limit *float32
	skip *float32
}

// $limit
func (r ApiNetworkingProjectNetgwEventListRequest) Limit(limit float32) ApiNetworkingProjectNetgwEventListRequest {
	r.limit = &limit
	return r
}
// $skip
func (r ApiNetworkingProjectNetgwEventListRequest) Skip(skip float32) ApiNetworkingProjectNetgwEventListRequest {
	r.skip = &skip
	return r
}

func (r ApiNetworkingProjectNetgwEventListRequest) Execute() ([]Event, *http.Response, error) {
	return r.ApiService.NetworkingProjectNetgwEventListExecute(r)
}

/*
NetworkingProjectNetgwEventList List networking/netgw.event

List networking/netgw.event

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param netgwId Netgw Id
 @return ApiNetworkingProjectNetgwEventListRequest
*/
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwEventList(ctx context.Context, projectId string, locationId string, netgwId string) ApiNetworkingProjectNetgwEventListRequest {
	return ApiNetworkingProjectNetgwEventListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netgwId: netgwId,
	}
}

// Execute executes the request
//  @return []Event
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwEventListExecute(r ApiNetworkingProjectNetgwEventListRequest) ([]Event, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetgwApiService.NetworkingProjectNetgwEventList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netgw/{netgwId}/event"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netgwId"+"}", url.PathEscape(parameterToString(r.netgwId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("$limit", parameterToString(*r.limit, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetgwGetRequest struct {
	ctx context.Context
	ApiService *NetworkingProjectNetgwApiService
	projectId string
	locationId string
	netgwId string
}


func (r ApiNetworkingProjectNetgwGetRequest) Execute() (*Netgw, *http.Response, error) {
	return r.ApiService.NetworkingProjectNetgwGetExecute(r)
}

/*
NetworkingProjectNetgwGet Get networking/netgw

Returns a single netgw

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param netgwId Netgw Id
 @return ApiNetworkingProjectNetgwGetRequest
*/
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwGet(ctx context.Context, projectId string, locationId string, netgwId string) ApiNetworkingProjectNetgwGetRequest {
	return ApiNetworkingProjectNetgwGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netgwId: netgwId,
	}
}

// Execute executes the request
//  @return Netgw
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwGetExecute(r ApiNetworkingProjectNetgwGetRequest) (*Netgw, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Netgw
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetgwApiService.NetworkingProjectNetgwGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netgw/{netgwId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netgwId"+"}", url.PathEscape(parameterToString(r.netgwId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetgwListRequest struct {
	ctx context.Context
	ApiService *NetworkingProjectNetgwApiService
	projectId string
	locationId string
	name *string
	tagValue *string
	tagKey *string
}

// Filter by name
func (r ApiNetworkingProjectNetgwListRequest) Name(name string) ApiNetworkingProjectNetgwListRequest {
	r.name = &name
	return r
}
// Filter by tag.value
func (r ApiNetworkingProjectNetgwListRequest) TagValue(tagValue string) ApiNetworkingProjectNetgwListRequest {
	r.tagValue = &tagValue
	return r
}
// Filter by tag.key
func (r ApiNetworkingProjectNetgwListRequest) TagKey(tagKey string) ApiNetworkingProjectNetgwListRequest {
	r.tagKey = &tagKey
	return r
}

func (r ApiNetworkingProjectNetgwListRequest) Execute() ([]Netgw, *http.Response, error) {
	return r.ApiService.NetworkingProjectNetgwListExecute(r)
}

/*
NetworkingProjectNetgwList List networking/netgw

List netgw

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @return ApiNetworkingProjectNetgwListRequest
*/
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwList(ctx context.Context, projectId string, locationId string) ApiNetworkingProjectNetgwListRequest {
	return ApiNetworkingProjectNetgwListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
	}
}

// Execute executes the request
//  @return []Netgw
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwListExecute(r ApiNetworkingProjectNetgwListRequest) ([]Netgw, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Netgw
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetgwApiService.NetworkingProjectNetgwList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netgw"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.tagValue != nil {
		localVarQueryParams.Add("tag.value", parameterToString(*r.tagValue, ""))
	}
	if r.tagKey != nil {
		localVarQueryParams.Add("tag.key", parameterToString(*r.tagKey, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetgwServiceGetRequest struct {
	ctx context.Context
	ApiService *NetworkingProjectNetgwApiService
	projectId string
	locationId string
	netgwId string
	serviceId string
}


func (r ApiNetworkingProjectNetgwServiceGetRequest) Execute() (*ResourceService, *http.Response, error) {
	return r.ApiService.NetworkingProjectNetgwServiceGetExecute(r)
}

/*
NetworkingProjectNetgwServiceGet Get networking/netgw.service

Get networking/netgw.service

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param netgwId Netgw Id
 @param serviceId serviceId
 @return ApiNetworkingProjectNetgwServiceGetRequest
*/
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwServiceGet(ctx context.Context, projectId string, locationId string, netgwId string, serviceId string) ApiNetworkingProjectNetgwServiceGetRequest {
	return ApiNetworkingProjectNetgwServiceGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netgwId: netgwId,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return ResourceService
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwServiceGetExecute(r ApiNetworkingProjectNetgwServiceGetRequest) (*ResourceService, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourceService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetgwApiService.NetworkingProjectNetgwServiceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netgw/{netgwId}/service/{serviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netgwId"+"}", url.PathEscape(parameterToString(r.netgwId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serviceId"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetgwServiceListRequest struct {
	ctx context.Context
	ApiService *NetworkingProjectNetgwApiService
	projectId string
	locationId string
	netgwId string
}


func (r ApiNetworkingProjectNetgwServiceListRequest) Execute() ([]ResourceService, *http.Response, error) {
	return r.ApiService.NetworkingProjectNetgwServiceListExecute(r)
}

/*
NetworkingProjectNetgwServiceList List networking/netgw.service

List networking/netgw.service

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param netgwId Netgw Id
 @return ApiNetworkingProjectNetgwServiceListRequest
*/
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwServiceList(ctx context.Context, projectId string, locationId string, netgwId string) ApiNetworkingProjectNetgwServiceListRequest {
	return ApiNetworkingProjectNetgwServiceListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netgwId: netgwId,
	}
}

// Execute executes the request
//  @return []ResourceService
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwServiceListExecute(r ApiNetworkingProjectNetgwServiceListRequest) ([]ResourceService, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ResourceService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetgwApiService.NetworkingProjectNetgwServiceList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netgw/{netgwId}/service"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netgwId"+"}", url.PathEscape(parameterToString(r.netgwId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetgwTagCreateRequest struct {
	ctx context.Context
	ApiService *NetworkingProjectNetgwApiService
	projectId string
	locationId string
	netgwId string
	tag *Tag
}

func (r ApiNetworkingProjectNetgwTagCreateRequest) Tag(tag Tag) ApiNetworkingProjectNetgwTagCreateRequest {
	r.tag = &tag
	return r
}

func (r ApiNetworkingProjectNetgwTagCreateRequest) Execute() (*Tag, *http.Response, error) {
	return r.ApiService.NetworkingProjectNetgwTagCreateExecute(r)
}

/*
NetworkingProjectNetgwTagCreate Create networking/netgw.tag

Create networking/netgw.tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param netgwId Netgw Id
 @return ApiNetworkingProjectNetgwTagCreateRequest
*/
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwTagCreate(ctx context.Context, projectId string, locationId string, netgwId string) ApiNetworkingProjectNetgwTagCreateRequest {
	return ApiNetworkingProjectNetgwTagCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netgwId: netgwId,
	}
}

// Execute executes the request
//  @return Tag
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwTagCreateExecute(r ApiNetworkingProjectNetgwTagCreateRequest) (*Tag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetgwApiService.NetworkingProjectNetgwTagCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netgw/{netgwId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netgwId"+"}", url.PathEscape(parameterToString(r.netgwId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tag == nil {
		return localVarReturnValue, nil, reportError("tag is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tag
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetgwTagDeleteRequest struct {
	ctx context.Context
	ApiService *NetworkingProjectNetgwApiService
	projectId string
	locationId string
	netgwId string
	tagId string
}


func (r ApiNetworkingProjectNetgwTagDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.NetworkingProjectNetgwTagDeleteExecute(r)
}

/*
NetworkingProjectNetgwTagDelete Delete networking/netgw.tag

Delete networking/netgw.tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param netgwId Netgw Id
 @param tagId tagId
 @return ApiNetworkingProjectNetgwTagDeleteRequest
*/
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwTagDelete(ctx context.Context, projectId string, locationId string, netgwId string, tagId string) ApiNetworkingProjectNetgwTagDeleteRequest {
	return ApiNetworkingProjectNetgwTagDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netgwId: netgwId,
		tagId: tagId,
	}
}

// Execute executes the request
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwTagDeleteExecute(r ApiNetworkingProjectNetgwTagDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetgwApiService.NetworkingProjectNetgwTagDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netgw/{netgwId}/tag/{tagId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netgwId"+"}", url.PathEscape(parameterToString(r.netgwId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", url.PathEscape(parameterToString(r.tagId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetgwTagGetRequest struct {
	ctx context.Context
	ApiService *NetworkingProjectNetgwApiService
	projectId string
	locationId string
	netgwId string
	tagId string
}


func (r ApiNetworkingProjectNetgwTagGetRequest) Execute() (*Tag, *http.Response, error) {
	return r.ApiService.NetworkingProjectNetgwTagGetExecute(r)
}

/*
NetworkingProjectNetgwTagGet Get networking/netgw.tag

Get networking/netgw.tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param netgwId Netgw Id
 @param tagId tagId
 @return ApiNetworkingProjectNetgwTagGetRequest
*/
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwTagGet(ctx context.Context, projectId string, locationId string, netgwId string, tagId string) ApiNetworkingProjectNetgwTagGetRequest {
	return ApiNetworkingProjectNetgwTagGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netgwId: netgwId,
		tagId: tagId,
	}
}

// Execute executes the request
//  @return Tag
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwTagGetExecute(r ApiNetworkingProjectNetgwTagGetRequest) (*Tag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetgwApiService.NetworkingProjectNetgwTagGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netgw/{netgwId}/tag/{tagId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netgwId"+"}", url.PathEscape(parameterToString(r.netgwId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", url.PathEscape(parameterToString(r.tagId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetgwTagListRequest struct {
	ctx context.Context
	ApiService *NetworkingProjectNetgwApiService
	projectId string
	locationId string
	netgwId string
}


func (r ApiNetworkingProjectNetgwTagListRequest) Execute() ([]Tag, *http.Response, error) {
	return r.ApiService.NetworkingProjectNetgwTagListExecute(r)
}

/*
NetworkingProjectNetgwTagList List networking/netgw.tag

List networking/netgw.tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param netgwId Netgw Id
 @return ApiNetworkingProjectNetgwTagListRequest
*/
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwTagList(ctx context.Context, projectId string, locationId string, netgwId string) ApiNetworkingProjectNetgwTagListRequest {
	return ApiNetworkingProjectNetgwTagListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netgwId: netgwId,
	}
}

// Execute executes the request
//  @return []Tag
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwTagListExecute(r ApiNetworkingProjectNetgwTagListRequest) ([]Tag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetgwApiService.NetworkingProjectNetgwTagList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netgw/{netgwId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netgwId"+"}", url.PathEscape(parameterToString(r.netgwId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetgwTagPutRequest struct {
	ctx context.Context
	ApiService *NetworkingProjectNetgwApiService
	projectId string
	locationId string
	netgwId string
	tag *[]Tag
}

func (r ApiNetworkingProjectNetgwTagPutRequest) Tag(tag []Tag) ApiNetworkingProjectNetgwTagPutRequest {
	r.tag = &tag
	return r
}

func (r ApiNetworkingProjectNetgwTagPutRequest) Execute() ([]Tag, *http.Response, error) {
	return r.ApiService.NetworkingProjectNetgwTagPutExecute(r)
}

/*
NetworkingProjectNetgwTagPut Replace networking/netgw.tag

Replace networking/netgw.tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param netgwId Netgw Id
 @return ApiNetworkingProjectNetgwTagPutRequest
*/
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwTagPut(ctx context.Context, projectId string, locationId string, netgwId string) ApiNetworkingProjectNetgwTagPutRequest {
	return ApiNetworkingProjectNetgwTagPutRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netgwId: netgwId,
	}
}

// Execute executes the request
//  @return []Tag
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwTagPutExecute(r ApiNetworkingProjectNetgwTagPutRequest) ([]Tag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetgwApiService.NetworkingProjectNetgwTagPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netgw/{netgwId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netgwId"+"}", url.PathEscape(parameterToString(r.netgwId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tag == nil {
		return localVarReturnValue, nil, reportError("tag is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tag
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNetworkingProjectNetgwUpdateRequest struct {
	ctx context.Context
	ApiService *NetworkingProjectNetgwApiService
	projectId string
	locationId string
	netgwId string
	networkingProjectNetgwUpdate *NetworkingProjectNetgwUpdate
}

func (r ApiNetworkingProjectNetgwUpdateRequest) NetworkingProjectNetgwUpdate(networkingProjectNetgwUpdate NetworkingProjectNetgwUpdate) ApiNetworkingProjectNetgwUpdateRequest {
	r.networkingProjectNetgwUpdate = &networkingProjectNetgwUpdate
	return r
}

func (r ApiNetworkingProjectNetgwUpdateRequest) Execute() (*Netgw, *http.Response, error) {
	return r.ApiService.NetworkingProjectNetgwUpdateExecute(r)
}

/*
NetworkingProjectNetgwUpdate Update networking/netgw

Returns modified netgw

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param netgwId Netgw Id
 @return ApiNetworkingProjectNetgwUpdateRequest
*/
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwUpdate(ctx context.Context, projectId string, locationId string, netgwId string) ApiNetworkingProjectNetgwUpdateRequest {
	return ApiNetworkingProjectNetgwUpdateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		netgwId: netgwId,
	}
}

// Execute executes the request
//  @return Netgw
func (a *NetworkingProjectNetgwApiService) NetworkingProjectNetgwUpdateExecute(r ApiNetworkingProjectNetgwUpdateRequest) (*Netgw, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Netgw
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NetworkingProjectNetgwApiService.NetworkingProjectNetgwUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networking/{locationId}/project/{projectId}/netgw/{netgwId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"netgwId"+"}", url.PathEscape(parameterToString(r.netgwId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.networkingProjectNetgwUpdate == nil {
		return localVarReturnValue, nil, reportError("networkingProjectNetgwUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.networkingProjectNetgwUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
