/*
HyperOne

HyperOne API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

// StorageProjectIsoApiService StorageProjectIsoApi service
type StorageProjectIsoApiService service

type ApiStorageProjectIsoCreateRequest struct {
	ctx context.Context
	ApiService *StorageProjectIsoApiService
	projectId string
	locationId string
	storageProjectIsoCreate *StorageProjectIsoCreate
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiStorageProjectIsoCreateRequest) StorageProjectIsoCreate(storageProjectIsoCreate StorageProjectIsoCreate) ApiStorageProjectIsoCreateRequest {
	r.storageProjectIsoCreate = &storageProjectIsoCreate
	return r
}
// Idempotency key
func (r ApiStorageProjectIsoCreateRequest) XIdempotencyKey(xIdempotencyKey string) ApiStorageProjectIsoCreateRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
// Dry run
func (r ApiStorageProjectIsoCreateRequest) XDryRun(xDryRun string) ApiStorageProjectIsoCreateRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiStorageProjectIsoCreateRequest) Execute() (*Iso, *http.Response, error) {
	return r.ApiService.StorageProjectIsoCreateExecute(r)
}

/*
StorageProjectIsoCreate Create storage/iso

Create iso

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @return ApiStorageProjectIsoCreateRequest
*/
func (a *StorageProjectIsoApiService) StorageProjectIsoCreate(ctx context.Context, projectId string, locationId string) ApiStorageProjectIsoCreateRequest {
	return ApiStorageProjectIsoCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
	}
}

// Execute executes the request
//  @return Iso
func (a *StorageProjectIsoApiService) StorageProjectIsoCreateExecute(r ApiStorageProjectIsoCreateRequest) (*Iso, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Iso
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageProjectIsoApiService.StorageProjectIsoCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/storage/{locationId}/project/{projectId}/iso"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.storageProjectIsoCreate == nil {
		return localVarReturnValue, nil, reportError("storageProjectIsoCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	// body params
	localVarPostBody = r.storageProjectIsoCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStorageProjectIsoDeleteRequest struct {
	ctx context.Context
	ApiService *StorageProjectIsoApiService
	projectId string
	locationId string
	isoId string
}


func (r ApiStorageProjectIsoDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.StorageProjectIsoDeleteExecute(r)
}

/*
StorageProjectIsoDelete Delete storage/iso

Delete iso

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param isoId Iso Id
 @return ApiStorageProjectIsoDeleteRequest
*/
func (a *StorageProjectIsoApiService) StorageProjectIsoDelete(ctx context.Context, projectId string, locationId string, isoId string) ApiStorageProjectIsoDeleteRequest {
	return ApiStorageProjectIsoDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		isoId: isoId,
	}
}

// Execute executes the request
func (a *StorageProjectIsoApiService) StorageProjectIsoDeleteExecute(r ApiStorageProjectIsoDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageProjectIsoApiService.StorageProjectIsoDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/storage/{locationId}/project/{projectId}/iso/{isoId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"isoId"+"}", url.PathEscape(parameterToString(r.isoId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStorageProjectIsoDetachRequest struct {
	ctx context.Context
	ApiService *StorageProjectIsoApiService
	projectId string
	locationId string
	isoId string
	storageProjectIsoDetach *StorageProjectIsoDetach
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiStorageProjectIsoDetachRequest) StorageProjectIsoDetach(storageProjectIsoDetach StorageProjectIsoDetach) ApiStorageProjectIsoDetachRequest {
	r.storageProjectIsoDetach = &storageProjectIsoDetach
	return r
}
// Idempotency key
func (r ApiStorageProjectIsoDetachRequest) XIdempotencyKey(xIdempotencyKey string) ApiStorageProjectIsoDetachRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
// Dry run
func (r ApiStorageProjectIsoDetachRequest) XDryRun(xDryRun string) ApiStorageProjectIsoDetachRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiStorageProjectIsoDetachRequest) Execute() (*Iso, *http.Response, error) {
	return r.ApiService.StorageProjectIsoDetachExecute(r)
}

/*
StorageProjectIsoDetach Detach storage/iso

action detach

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param isoId Iso Id
 @return ApiStorageProjectIsoDetachRequest
*/
func (a *StorageProjectIsoApiService) StorageProjectIsoDetach(ctx context.Context, projectId string, locationId string, isoId string) ApiStorageProjectIsoDetachRequest {
	return ApiStorageProjectIsoDetachRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		isoId: isoId,
	}
}

// Execute executes the request
//  @return Iso
func (a *StorageProjectIsoApiService) StorageProjectIsoDetachExecute(r ApiStorageProjectIsoDetachRequest) (*Iso, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Iso
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageProjectIsoApiService.StorageProjectIsoDetach")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/storage/{locationId}/project/{projectId}/iso/{isoId}/actions/detach"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"isoId"+"}", url.PathEscape(parameterToString(r.isoId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.storageProjectIsoDetach == nil {
		return localVarReturnValue, nil, reportError("storageProjectIsoDetach is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	// body params
	localVarPostBody = r.storageProjectIsoDetach
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStorageProjectIsoEventGetRequest struct {
	ctx context.Context
	ApiService *StorageProjectIsoApiService
	projectId string
	locationId string
	isoId string
	eventId string
}


func (r ApiStorageProjectIsoEventGetRequest) Execute() (*Event, *http.Response, error) {
	return r.ApiService.StorageProjectIsoEventGetExecute(r)
}

/*
StorageProjectIsoEventGet Get storage/iso.event

Get storage/iso.event

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param isoId Iso Id
 @param eventId eventId
 @return ApiStorageProjectIsoEventGetRequest
*/
func (a *StorageProjectIsoApiService) StorageProjectIsoEventGet(ctx context.Context, projectId string, locationId string, isoId string, eventId string) ApiStorageProjectIsoEventGetRequest {
	return ApiStorageProjectIsoEventGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		isoId: isoId,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return Event
func (a *StorageProjectIsoApiService) StorageProjectIsoEventGetExecute(r ApiStorageProjectIsoEventGetRequest) (*Event, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageProjectIsoApiService.StorageProjectIsoEventGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/storage/{locationId}/project/{projectId}/iso/{isoId}/event/{eventId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"isoId"+"}", url.PathEscape(parameterToString(r.isoId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", url.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStorageProjectIsoEventListRequest struct {
	ctx context.Context
	ApiService *StorageProjectIsoApiService
	projectId string
	locationId string
	isoId string
	limit *float32
	skip *float32
}

// $limit
func (r ApiStorageProjectIsoEventListRequest) Limit(limit float32) ApiStorageProjectIsoEventListRequest {
	r.limit = &limit
	return r
}
// $skip
func (r ApiStorageProjectIsoEventListRequest) Skip(skip float32) ApiStorageProjectIsoEventListRequest {
	r.skip = &skip
	return r
}

func (r ApiStorageProjectIsoEventListRequest) Execute() ([]Event, *http.Response, error) {
	return r.ApiService.StorageProjectIsoEventListExecute(r)
}

/*
StorageProjectIsoEventList List storage/iso.event

List storage/iso.event

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param isoId Iso Id
 @return ApiStorageProjectIsoEventListRequest
*/
func (a *StorageProjectIsoApiService) StorageProjectIsoEventList(ctx context.Context, projectId string, locationId string, isoId string) ApiStorageProjectIsoEventListRequest {
	return ApiStorageProjectIsoEventListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		isoId: isoId,
	}
}

// Execute executes the request
//  @return []Event
func (a *StorageProjectIsoApiService) StorageProjectIsoEventListExecute(r ApiStorageProjectIsoEventListRequest) ([]Event, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Event
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageProjectIsoApiService.StorageProjectIsoEventList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/storage/{locationId}/project/{projectId}/iso/{isoId}/event"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"isoId"+"}", url.PathEscape(parameterToString(r.isoId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("$limit", parameterToString(*r.limit, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("$skip", parameterToString(*r.skip, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStorageProjectIsoGetRequest struct {
	ctx context.Context
	ApiService *StorageProjectIsoApiService
	projectId string
	locationId string
	isoId string
}


func (r ApiStorageProjectIsoGetRequest) Execute() (*Iso, *http.Response, error) {
	return r.ApiService.StorageProjectIsoGetExecute(r)
}

/*
StorageProjectIsoGet Get storage/iso

Returns a single iso

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param isoId Iso Id
 @return ApiStorageProjectIsoGetRequest
*/
func (a *StorageProjectIsoApiService) StorageProjectIsoGet(ctx context.Context, projectId string, locationId string, isoId string) ApiStorageProjectIsoGetRequest {
	return ApiStorageProjectIsoGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		isoId: isoId,
	}
}

// Execute executes the request
//  @return Iso
func (a *StorageProjectIsoApiService) StorageProjectIsoGetExecute(r ApiStorageProjectIsoGetRequest) (*Iso, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Iso
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageProjectIsoApiService.StorageProjectIsoGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/storage/{locationId}/project/{projectId}/iso/{isoId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"isoId"+"}", url.PathEscape(parameterToString(r.isoId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStorageProjectIsoListRequest struct {
	ctx context.Context
	ApiService *StorageProjectIsoApiService
	projectId string
	locationId string
	name *string
	tagValue *string
	tagKey *string
}

// Filter by name
func (r ApiStorageProjectIsoListRequest) Name(name string) ApiStorageProjectIsoListRequest {
	r.name = &name
	return r
}
// Filter by tag.value
func (r ApiStorageProjectIsoListRequest) TagValue(tagValue string) ApiStorageProjectIsoListRequest {
	r.tagValue = &tagValue
	return r
}
// Filter by tag.key
func (r ApiStorageProjectIsoListRequest) TagKey(tagKey string) ApiStorageProjectIsoListRequest {
	r.tagKey = &tagKey
	return r
}

func (r ApiStorageProjectIsoListRequest) Execute() ([]Iso, *http.Response, error) {
	return r.ApiService.StorageProjectIsoListExecute(r)
}

/*
StorageProjectIsoList List storage/iso

List iso

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @return ApiStorageProjectIsoListRequest
*/
func (a *StorageProjectIsoApiService) StorageProjectIsoList(ctx context.Context, projectId string, locationId string) ApiStorageProjectIsoListRequest {
	return ApiStorageProjectIsoListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
	}
}

// Execute executes the request
//  @return []Iso
func (a *StorageProjectIsoApiService) StorageProjectIsoListExecute(r ApiStorageProjectIsoListRequest) ([]Iso, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Iso
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageProjectIsoApiService.StorageProjectIsoList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/storage/{locationId}/project/{projectId}/iso"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.tagValue != nil {
		localVarQueryParams.Add("tag.value", parameterToString(*r.tagValue, ""))
	}
	if r.tagKey != nil {
		localVarQueryParams.Add("tag.key", parameterToString(*r.tagKey, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStorageProjectIsoServiceGetRequest struct {
	ctx context.Context
	ApiService *StorageProjectIsoApiService
	projectId string
	locationId string
	isoId string
	serviceId string
}


func (r ApiStorageProjectIsoServiceGetRequest) Execute() (*ResourceService, *http.Response, error) {
	return r.ApiService.StorageProjectIsoServiceGetExecute(r)
}

/*
StorageProjectIsoServiceGet Get storage/iso.service

Get storage/iso.service

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param isoId Iso Id
 @param serviceId serviceId
 @return ApiStorageProjectIsoServiceGetRequest
*/
func (a *StorageProjectIsoApiService) StorageProjectIsoServiceGet(ctx context.Context, projectId string, locationId string, isoId string, serviceId string) ApiStorageProjectIsoServiceGetRequest {
	return ApiStorageProjectIsoServiceGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		isoId: isoId,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return ResourceService
func (a *StorageProjectIsoApiService) StorageProjectIsoServiceGetExecute(r ApiStorageProjectIsoServiceGetRequest) (*ResourceService, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourceService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageProjectIsoApiService.StorageProjectIsoServiceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/storage/{locationId}/project/{projectId}/iso/{isoId}/service/{serviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"isoId"+"}", url.PathEscape(parameterToString(r.isoId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serviceId"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStorageProjectIsoServiceListRequest struct {
	ctx context.Context
	ApiService *StorageProjectIsoApiService
	projectId string
	locationId string
	isoId string
}


func (r ApiStorageProjectIsoServiceListRequest) Execute() ([]ResourceService, *http.Response, error) {
	return r.ApiService.StorageProjectIsoServiceListExecute(r)
}

/*
StorageProjectIsoServiceList List storage/iso.service

List storage/iso.service

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param isoId Iso Id
 @return ApiStorageProjectIsoServiceListRequest
*/
func (a *StorageProjectIsoApiService) StorageProjectIsoServiceList(ctx context.Context, projectId string, locationId string, isoId string) ApiStorageProjectIsoServiceListRequest {
	return ApiStorageProjectIsoServiceListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		isoId: isoId,
	}
}

// Execute executes the request
//  @return []ResourceService
func (a *StorageProjectIsoApiService) StorageProjectIsoServiceListExecute(r ApiStorageProjectIsoServiceListRequest) ([]ResourceService, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ResourceService
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageProjectIsoApiService.StorageProjectIsoServiceList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/storage/{locationId}/project/{projectId}/iso/{isoId}/service"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"isoId"+"}", url.PathEscape(parameterToString(r.isoId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStorageProjectIsoTagCreateRequest struct {
	ctx context.Context
	ApiService *StorageProjectIsoApiService
	projectId string
	locationId string
	isoId string
	tag *Tag
}

func (r ApiStorageProjectIsoTagCreateRequest) Tag(tag Tag) ApiStorageProjectIsoTagCreateRequest {
	r.tag = &tag
	return r
}

func (r ApiStorageProjectIsoTagCreateRequest) Execute() (*Tag, *http.Response, error) {
	return r.ApiService.StorageProjectIsoTagCreateExecute(r)
}

/*
StorageProjectIsoTagCreate Create storage/iso.tag

Create storage/iso.tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param isoId Iso Id
 @return ApiStorageProjectIsoTagCreateRequest
*/
func (a *StorageProjectIsoApiService) StorageProjectIsoTagCreate(ctx context.Context, projectId string, locationId string, isoId string) ApiStorageProjectIsoTagCreateRequest {
	return ApiStorageProjectIsoTagCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		isoId: isoId,
	}
}

// Execute executes the request
//  @return Tag
func (a *StorageProjectIsoApiService) StorageProjectIsoTagCreateExecute(r ApiStorageProjectIsoTagCreateRequest) (*Tag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageProjectIsoApiService.StorageProjectIsoTagCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/storage/{locationId}/project/{projectId}/iso/{isoId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"isoId"+"}", url.PathEscape(parameterToString(r.isoId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tag == nil {
		return localVarReturnValue, nil, reportError("tag is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tag
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStorageProjectIsoTagDeleteRequest struct {
	ctx context.Context
	ApiService *StorageProjectIsoApiService
	projectId string
	locationId string
	isoId string
	tagId string
}


func (r ApiStorageProjectIsoTagDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.StorageProjectIsoTagDeleteExecute(r)
}

/*
StorageProjectIsoTagDelete Delete storage/iso.tag

Delete storage/iso.tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param isoId Iso Id
 @param tagId tagId
 @return ApiStorageProjectIsoTagDeleteRequest
*/
func (a *StorageProjectIsoApiService) StorageProjectIsoTagDelete(ctx context.Context, projectId string, locationId string, isoId string, tagId string) ApiStorageProjectIsoTagDeleteRequest {
	return ApiStorageProjectIsoTagDeleteRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		isoId: isoId,
		tagId: tagId,
	}
}

// Execute executes the request
func (a *StorageProjectIsoApiService) StorageProjectIsoTagDeleteExecute(r ApiStorageProjectIsoTagDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageProjectIsoApiService.StorageProjectIsoTagDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/storage/{locationId}/project/{projectId}/iso/{isoId}/tag/{tagId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"isoId"+"}", url.PathEscape(parameterToString(r.isoId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", url.PathEscape(parameterToString(r.tagId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStorageProjectIsoTagGetRequest struct {
	ctx context.Context
	ApiService *StorageProjectIsoApiService
	projectId string
	locationId string
	isoId string
	tagId string
}


func (r ApiStorageProjectIsoTagGetRequest) Execute() (*Tag, *http.Response, error) {
	return r.ApiService.StorageProjectIsoTagGetExecute(r)
}

/*
StorageProjectIsoTagGet Get storage/iso.tag

Get storage/iso.tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param isoId Iso Id
 @param tagId tagId
 @return ApiStorageProjectIsoTagGetRequest
*/
func (a *StorageProjectIsoApiService) StorageProjectIsoTagGet(ctx context.Context, projectId string, locationId string, isoId string, tagId string) ApiStorageProjectIsoTagGetRequest {
	return ApiStorageProjectIsoTagGetRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		isoId: isoId,
		tagId: tagId,
	}
}

// Execute executes the request
//  @return Tag
func (a *StorageProjectIsoApiService) StorageProjectIsoTagGetExecute(r ApiStorageProjectIsoTagGetRequest) (*Tag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageProjectIsoApiService.StorageProjectIsoTagGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/storage/{locationId}/project/{projectId}/iso/{isoId}/tag/{tagId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"isoId"+"}", url.PathEscape(parameterToString(r.isoId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tagId"+"}", url.PathEscape(parameterToString(r.tagId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStorageProjectIsoTagListRequest struct {
	ctx context.Context
	ApiService *StorageProjectIsoApiService
	projectId string
	locationId string
	isoId string
}


func (r ApiStorageProjectIsoTagListRequest) Execute() ([]Tag, *http.Response, error) {
	return r.ApiService.StorageProjectIsoTagListExecute(r)
}

/*
StorageProjectIsoTagList List storage/iso.tag

List storage/iso.tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param isoId Iso Id
 @return ApiStorageProjectIsoTagListRequest
*/
func (a *StorageProjectIsoApiService) StorageProjectIsoTagList(ctx context.Context, projectId string, locationId string, isoId string) ApiStorageProjectIsoTagListRequest {
	return ApiStorageProjectIsoTagListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		isoId: isoId,
	}
}

// Execute executes the request
//  @return []Tag
func (a *StorageProjectIsoApiService) StorageProjectIsoTagListExecute(r ApiStorageProjectIsoTagListRequest) ([]Tag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageProjectIsoApiService.StorageProjectIsoTagList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/storage/{locationId}/project/{projectId}/iso/{isoId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"isoId"+"}", url.PathEscape(parameterToString(r.isoId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStorageProjectIsoTagPutRequest struct {
	ctx context.Context
	ApiService *StorageProjectIsoApiService
	projectId string
	locationId string
	isoId string
	tag *[]Tag
}

func (r ApiStorageProjectIsoTagPutRequest) Tag(tag []Tag) ApiStorageProjectIsoTagPutRequest {
	r.tag = &tag
	return r
}

func (r ApiStorageProjectIsoTagPutRequest) Execute() ([]Tag, *http.Response, error) {
	return r.ApiService.StorageProjectIsoTagPutExecute(r)
}

/*
StorageProjectIsoTagPut Replace storage/iso.tag

Replace storage/iso.tag

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param isoId Iso Id
 @return ApiStorageProjectIsoTagPutRequest
*/
func (a *StorageProjectIsoApiService) StorageProjectIsoTagPut(ctx context.Context, projectId string, locationId string, isoId string) ApiStorageProjectIsoTagPutRequest {
	return ApiStorageProjectIsoTagPutRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		isoId: isoId,
	}
}

// Execute executes the request
//  @return []Tag
func (a *StorageProjectIsoApiService) StorageProjectIsoTagPutExecute(r ApiStorageProjectIsoTagPutRequest) ([]Tag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageProjectIsoApiService.StorageProjectIsoTagPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/storage/{locationId}/project/{projectId}/iso/{isoId}/tag"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"isoId"+"}", url.PathEscape(parameterToString(r.isoId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tag == nil {
		return localVarReturnValue, nil, reportError("tag is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tag
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStorageProjectIsoTransferRequest struct {
	ctx context.Context
	ApiService *StorageProjectIsoApiService
	projectId string
	locationId string
	isoId string
	storageProjectIsoTransfer *StorageProjectIsoTransfer
	xIdempotencyKey *string
	xDryRun *string
}

func (r ApiStorageProjectIsoTransferRequest) StorageProjectIsoTransfer(storageProjectIsoTransfer StorageProjectIsoTransfer) ApiStorageProjectIsoTransferRequest {
	r.storageProjectIsoTransfer = &storageProjectIsoTransfer
	return r
}
// Idempotency key
func (r ApiStorageProjectIsoTransferRequest) XIdempotencyKey(xIdempotencyKey string) ApiStorageProjectIsoTransferRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}
// Dry run
func (r ApiStorageProjectIsoTransferRequest) XDryRun(xDryRun string) ApiStorageProjectIsoTransferRequest {
	r.xDryRun = &xDryRun
	return r
}

func (r ApiStorageProjectIsoTransferRequest) Execute() (*Iso, *http.Response, error) {
	return r.ApiService.StorageProjectIsoTransferExecute(r)
}

/*
StorageProjectIsoTransfer Transfer storage/iso

action transfer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param isoId Iso Id
 @return ApiStorageProjectIsoTransferRequest
*/
func (a *StorageProjectIsoApiService) StorageProjectIsoTransfer(ctx context.Context, projectId string, locationId string, isoId string) ApiStorageProjectIsoTransferRequest {
	return ApiStorageProjectIsoTransferRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		isoId: isoId,
	}
}

// Execute executes the request
//  @return Iso
func (a *StorageProjectIsoApiService) StorageProjectIsoTransferExecute(r ApiStorageProjectIsoTransferRequest) (*Iso, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Iso
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageProjectIsoApiService.StorageProjectIsoTransfer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/storage/{locationId}/project/{projectId}/iso/{isoId}/actions/transfer"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"isoId"+"}", url.PathEscape(parameterToString(r.isoId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.storageProjectIsoTransfer == nil {
		return localVarReturnValue, nil, reportError("storageProjectIsoTransfer is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xIdempotencyKey != nil {
		localVarHeaderParams["x-idempotency-key"] = parameterToString(*r.xIdempotencyKey, "")
	}
	if r.xDryRun != nil {
		localVarHeaderParams["x-dry-run"] = parameterToString(*r.xDryRun, "")
	}
	// body params
	localVarPostBody = r.storageProjectIsoTransfer
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStorageProjectIsoUpdateRequest struct {
	ctx context.Context
	ApiService *StorageProjectIsoApiService
	projectId string
	locationId string
	isoId string
	storageProjectIsoUpdate *StorageProjectIsoUpdate
}

func (r ApiStorageProjectIsoUpdateRequest) StorageProjectIsoUpdate(storageProjectIsoUpdate StorageProjectIsoUpdate) ApiStorageProjectIsoUpdateRequest {
	r.storageProjectIsoUpdate = &storageProjectIsoUpdate
	return r
}

func (r ApiStorageProjectIsoUpdateRequest) Execute() (*Iso, *http.Response, error) {
	return r.ApiService.StorageProjectIsoUpdateExecute(r)
}

/*
StorageProjectIsoUpdate Update storage/iso

Returns modified iso

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project Id
 @param locationId Location Id
 @param isoId Iso Id
 @return ApiStorageProjectIsoUpdateRequest
*/
func (a *StorageProjectIsoApiService) StorageProjectIsoUpdate(ctx context.Context, projectId string, locationId string, isoId string) ApiStorageProjectIsoUpdateRequest {
	return ApiStorageProjectIsoUpdateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		locationId: locationId,
		isoId: isoId,
	}
}

// Execute executes the request
//  @return Iso
func (a *StorageProjectIsoApiService) StorageProjectIsoUpdateExecute(r ApiStorageProjectIsoUpdateRequest) (*Iso, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Iso
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StorageProjectIsoApiService.StorageProjectIsoUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/storage/{locationId}/project/{projectId}/iso/{isoId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", url.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locationId"+"}", url.PathEscape(parameterToString(r.locationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"isoId"+"}", url.PathEscape(parameterToString(r.isoId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.storageProjectIsoUpdate == nil {
		return localVarReturnValue, nil, reportError("storageProjectIsoUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.storageProjectIsoUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
